package ldk_node

/*


// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

#include <stdbool.h>
#include <stdint.h>

// The following structs are used to implement the lowest level
// of the FFI, and thus useful to multiple uniffied crates.
// We ensure they are declared exactly once, with a header guard, UNIFFI_SHARED_H.
#ifdef UNIFFI_SHARED_H
	// We also try to prevent mixing versions of shared uniffi header structs.
	// If you add anything to the #else block, you must increment the version suffix in UNIFFI_SHARED_HEADER_V4
	#ifndef UNIFFI_SHARED_HEADER_V4
		#error Combining helper code from multiple versions of uniffi is not supported
	#endif // ndef UNIFFI_SHARED_HEADER_V4
#else
#define UNIFFI_SHARED_H
#define UNIFFI_SHARED_HEADER_V4
// ⚠️ Attention: If you change this #else block (ending in `#endif // def UNIFFI_SHARED_H`) you *must* ⚠️
// ⚠️ increment the version suffix in all instances of UNIFFI_SHARED_HEADER_V4 in this file.           ⚠️

typedef struct RustBuffer {
	int32_t capacity;
	int32_t len;
	uint8_t *data;
} RustBuffer;

typedef int32_t (*ForeignCallback)(uint64_t, int32_t, RustBuffer, RustBuffer *);

typedef struct ForeignBytes {
	int32_t len;
	const uint8_t *data;
} ForeignBytes;

// Error definitions
typedef struct RustCallStatus {
	int8_t code;
	RustBuffer errorBuf;
} RustCallStatus;

// ⚠️ Attention: If you change this #else block (ending in `#endif // def UNIFFI_SHARED_H`) you *must* ⚠️
// ⚠️ increment the version suffix in all instances of UNIFFI_SHARED_HEADER_V4 in this file.           ⚠️
#endif // def UNIFFI_SHARED_H

void ffi_ldk_node_cc4c_Builder_object_free(
	void* ptr,
	RustCallStatus* out_status
);

void* ldk_node_cc4c_Builder_new(
	RustCallStatus* out_status
);

void* ldk_node_cc4c_Builder_from_config(
	RustBuffer config,
	RustCallStatus* out_status
);

void ldk_node_cc4c_Builder_set_entropy_seed_path(
	void* ptr,
	RustBuffer seed_path,
	RustCallStatus* out_status
);

void ldk_node_cc4c_Builder_set_entropy_seed_bytes(
	void* ptr,
	RustBuffer seed_bytes,
	RustCallStatus* out_status
);

void ldk_node_cc4c_Builder_set_entropy_bip39_mnemonic(
	void* ptr,
	RustBuffer mnemonic,
	RustBuffer passphrase,
	RustCallStatus* out_status
);

void ldk_node_cc4c_Builder_set_esplora_server(
	void* ptr,
	RustBuffer esplora_server_url,
	RustCallStatus* out_status
);

void ldk_node_cc4c_Builder_set_gossip_source_p2p(
	void* ptr,
	RustCallStatus* out_status
);

void ldk_node_cc4c_Builder_set_gossip_source_rgs(
	void* ptr,
	RustBuffer rgs_server_url,
	RustCallStatus* out_status
);

void ldk_node_cc4c_Builder_set_storage_dir_path(
	void* ptr,
	RustBuffer storage_dir_path,
	RustCallStatus* out_status
);

void ldk_node_cc4c_Builder_set_network(
	void* ptr,
	RustBuffer network,
	RustCallStatus* out_status
);

void ldk_node_cc4c_Builder_set_listening_address(
	void* ptr,
	RustBuffer listening_address,
	RustCallStatus* out_status
);

void* ldk_node_cc4c_Builder_build(
	void* ptr,
	RustCallStatus* out_status
);

void ffi_ldk_node_cc4c_LDKNode_object_free(
	void* ptr,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_start(
	void* ptr,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_stop(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_next_event(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_wait_next_event(
	void* ptr,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_event_handled(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_node_id(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_listening_address(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_new_onchain_address(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_send_to_onchain_address(
	void* ptr,
	RustBuffer address,
	uint64_t amount_msat,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_send_all_to_onchain_address(
	void* ptr,
	RustBuffer address,
	RustCallStatus* out_status
);

uint64_t ldk_node_cc4c_LDKNode_spendable_onchain_balance_sats(
	void* ptr,
	RustCallStatus* out_status
);

uint64_t ldk_node_cc4c_LDKNode_total_onchain_balance_sats(
	void* ptr,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_connect(
	void* ptr,
	RustBuffer node_id,
	RustBuffer address,
	int8_t persist,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_disconnect(
	void* ptr,
	RustBuffer node_id,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_connect_open_channel(
	void* ptr,
	RustBuffer node_id,
	RustBuffer address,
	uint64_t channel_amount_sats,
	RustBuffer push_to_counterparty_msat,
	RustBuffer channel_config,
	int8_t announce_channel,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_close_channel(
	void* ptr,
	RustBuffer channel_id,
	RustBuffer counterparty_node_id,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_update_channel_config(
	void* ptr,
	RustBuffer channel_id,
	RustBuffer counterparty_node_id,
	void* channel_config,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_sync_wallets(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_send_payment(
	void* ptr,
	RustBuffer invoice,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_send_payment_using_amount(
	void* ptr,
	RustBuffer invoice,
	uint64_t amount_msat,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_send_spontaneous_payment(
	void* ptr,
	uint64_t amount_msat,
	RustBuffer node_id,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_send_payment_probe(
	void* ptr,
	RustBuffer invoice,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_send_spontaneous_payment_probe(
	void* ptr,
	uint64_t amount_msat,
	RustBuffer node_id,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_receive_payment(
	void* ptr,
	uint64_t amount_msat,
	RustBuffer description,
	uint32_t expiry_secs,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_receive_variable_amount_payment(
	void* ptr,
	RustBuffer description,
	uint32_t expiry_secs,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_payment(
	void* ptr,
	RustBuffer payment_hash,
	RustCallStatus* out_status
);

void ldk_node_cc4c_LDKNode_remove_payment(
	void* ptr,
	RustBuffer payment_hash,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_list_payments(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_list_peers(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_list_channels(
	void* ptr,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_LDKNode_sign_message(
	void* ptr,
	RustBuffer msg,
	RustCallStatus* out_status
);

int8_t ldk_node_cc4c_LDKNode_verify_signature(
	void* ptr,
	RustBuffer msg,
	RustBuffer sig,
	RustBuffer pkey,
	RustCallStatus* out_status
);

int8_t ldk_node_cc4c_LDKNode_is_running(
	void* ptr,
	RustCallStatus* out_status
);

void ffi_ldk_node_cc4c_ChannelConfig_object_free(
	void* ptr,
	RustCallStatus* out_status
);

void* ldk_node_cc4c_ChannelConfig_new(
	RustCallStatus* out_status
);

uint32_t ldk_node_cc4c_ChannelConfig_forwarding_fee_proportional_millionths(
	void* ptr,
	RustCallStatus* out_status
);

void ldk_node_cc4c_ChannelConfig_set_forwarding_fee_proportional_millionths(
	void* ptr,
	uint32_t value,
	RustCallStatus* out_status
);

uint32_t ldk_node_cc4c_ChannelConfig_forwarding_fee_base_msat(
	void* ptr,
	RustCallStatus* out_status
);

void ldk_node_cc4c_ChannelConfig_set_forwarding_fee_base_msat(
	void* ptr,
	uint32_t fee_msat,
	RustCallStatus* out_status
);

uint16_t ldk_node_cc4c_ChannelConfig_cltv_expiry_delta(
	void* ptr,
	RustCallStatus* out_status
);

void ldk_node_cc4c_ChannelConfig_set_cltv_expiry_delta(
	void* ptr,
	uint16_t value,
	RustCallStatus* out_status
);

uint64_t ldk_node_cc4c_ChannelConfig_force_close_avoidance_max_fee_satoshis(
	void* ptr,
	RustCallStatus* out_status
);

void ldk_node_cc4c_ChannelConfig_set_force_close_avoidance_max_fee_satoshis(
	void* ptr,
	uint64_t value_sat,
	RustCallStatus* out_status
);

int8_t ldk_node_cc4c_ChannelConfig_accept_underpaying_htlcs(
	void* ptr,
	RustCallStatus* out_status
);

void ldk_node_cc4c_ChannelConfig_set_accept_underpaying_htlcs(
	void* ptr,
	int8_t value,
	RustCallStatus* out_status
);

void ldk_node_cc4c_ChannelConfig_set_max_dust_htlc_exposure_from_fixed_limit(
	void* ptr,
	uint64_t limit_msat,
	RustCallStatus* out_status
);

void ldk_node_cc4c_ChannelConfig_set_max_dust_htlc_exposure_from_fee_rate_multiplier(
	void* ptr,
	uint64_t multiplier,
	RustCallStatus* out_status
);

RustBuffer ldk_node_cc4c_generate_entropy_mnemonic(
	RustCallStatus* out_status
);

RustBuffer ffi_ldk_node_cc4c_rustbuffer_alloc(
	int32_t size,
	RustCallStatus* out_status
);

RustBuffer ffi_ldk_node_cc4c_rustbuffer_from_bytes(
	ForeignBytes bytes,
	RustCallStatus* out_status
);

void ffi_ldk_node_cc4c_rustbuffer_free(
	RustBuffer buf,
	RustCallStatus* out_status
);

RustBuffer ffi_ldk_node_cc4c_rustbuffer_reserve(
	RustBuffer buf,
	int32_t additional,
	RustCallStatus* out_status
);


*/
// #cgo LDFLAGS: -L${SRCDIR} -lldk_node
// #include "ldk_node.h"
import "C"

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"math"
	"runtime"
	"sync/atomic"
	"unsafe"
)

type rustBuffer struct {
	capacity int
	length   int
	data     unsafe.Pointer
	self     C.RustBuffer
}

func fromCRustBuffer(crbuf C.RustBuffer) rustBuffer {
	return rustBuffer{
		capacity: int(crbuf.capacity),
		length:   int(crbuf.len),
		data:     unsafe.Pointer(crbuf.data),
		self:     crbuf,
	}
}

// asByteBuffer reads the full rust buffer and then converts read bytes to a new reader which makes
// it quite inefficient
// TODO: Return an implementation which reads only when needed
func (rb rustBuffer) asReader() *bytes.Reader {
	b := C.GoBytes(rb.data, C.int(rb.length))
	return bytes.NewReader(b)
}

func (rb rustBuffer) asCRustBuffer() C.RustBuffer {
	return C.RustBuffer{
		capacity: C.int(rb.capacity),
		len:      C.int(rb.length),
		data:     (*C.uchar)(unsafe.Pointer(rb.data)),
	}
}

func stringToCRustBuffer(str string) C.RustBuffer {
	b := []byte(str)
	cs := C.CString(str)
	return C.RustBuffer{
		capacity: C.int(len(b)),
		len:      C.int(len(b)),
		data:     (*C.uchar)(unsafe.Pointer(cs)),
	}
}

func (rb rustBuffer) free() {
	rustCall(func(status *C.RustCallStatus) bool {
		C.ffi_ldk_node_cc4c_rustbuffer_free(rb.self, status)
		return false
	})
}

type bufLifter[GoType any] interface {
	lift(value C.RustBuffer) GoType
}

type bufLowerer[GoType any] interface {
	lower(value GoType) C.RustBuffer
}

type ffiConverter[GoType any, FfiType any] interface {
	lift(value FfiType) GoType
	lower(value GoType) FfiType
}

type bufReader[GoType any] interface {
	read(reader io.Reader) GoType
}

type bufWriter[GoType any] interface {
	write(writer io.Writer, value GoType)
}

type ffiRustBufConverter[GoType any, FfiType any] interface {
	ffiConverter[GoType, FfiType]
	bufReader[GoType]
}

func lowerIntoRustBuffer[GoType any](bufWriter bufWriter[GoType], value GoType) C.RustBuffer {
	// This might be not the most efficient way but it does not require knowing allocation size
	// beforehand
	var buffer bytes.Buffer
	bufWriter.write(&buffer, value)

	bytes, err := io.ReadAll(&buffer)
	if err != nil {
		panic(fmt.Errorf("reading written data: %w", err))
	}

	return stringToCRustBuffer(string(bytes))
}

func liftFromRustBuffer[GoType any](bufReader bufReader[GoType], rbuf rustBuffer) GoType {
	defer rbuf.free()
	reader := rbuf.asReader()
	item := bufReader.read(reader)
	if reader.Len() > 0 {
		// TODO: Remove this
		leftover, _ := io.ReadAll(reader)
		panic(fmt.Errorf("Junk remaining in buffer after lifting: %s", string(leftover)))
	}
	return item
}

func rustCallWithError[U any](converter bufLifter[error], callback func(*C.RustCallStatus) U) (U, error) {
	var status C.RustCallStatus
	returnValue := callback(&status)
	switch status.code {
	case 0:
		return returnValue, nil
	case 1:
		return returnValue, converter.lift(status.errorBuf)
	case 2:
		// when the rust code sees a panic, it tries to construct a rustbuffer
		// with the message.  but if that code panics, then it just sends back
		// an empty buffer.
		if status.errorBuf.len > 0 {
			panic(fmt.Errorf("%s", FfiConverterstringINSTANCE.lift(status.errorBuf)))
		} else {
			panic(fmt.Errorf("Rust panicked while handling Rust panic"))
		}
	default:
		return returnValue, fmt.Errorf("unknown status code: %d", status.code)
	}
}

func rustCall[U any](callback func(*C.RustCallStatus) U) U {
	returnValue, err := rustCallWithError(nil, callback)
	if err != nil {
		panic(err)
	}
	return returnValue
}

func writeInt8(writer io.Writer, value int8) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint8(writer io.Writer, value uint8) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt16(writer io.Writer, value int16) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint16(writer io.Writer, value uint16) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt32(writer io.Writer, value int32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint32(writer io.Writer, value uint32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeInt64(writer io.Writer, value int64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeUint64(writer io.Writer, value uint64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeFloat32(writer io.Writer, value float32) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func writeFloat64(writer io.Writer, value float64) {
	if err := binary.Write(writer, binary.BigEndian, value); err != nil {
		panic(err)
	}
}

func readInt8(reader io.Reader) int8 {
	var result int8
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint8(reader io.Reader) uint8 {
	var result uint8
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt16(reader io.Reader) int16 {
	var result int16
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint16(reader io.Reader) uint16 {
	var result uint16
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt32(reader io.Reader) int32 {
	var result int32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint32(reader io.Reader) uint32 {
	var result uint32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readInt64(reader io.Reader) int64 {
	var result int64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readUint64(reader io.Reader) uint64 {
	var result uint64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readFloat32(reader io.Reader) float32 {
	var result float32
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func readFloat64(reader io.Reader) float64 {
	var result float64
	if err := binary.Read(reader, binary.BigEndian, &result); err != nil {
		panic(err)
	}
	return result
}

func init() {

}

type FfiConverteruint8 struct{}

var FfiConverteruint8INSTANCE = FfiConverteruint8{}

func (FfiConverteruint8) lower(value uint8) C.uint8_t {
	return C.uint8_t(value)
}

func (FfiConverteruint8) write(writer io.Writer, value uint8) {
	writeUint8(writer, value)
}

func (FfiConverteruint8) lift(value C.uint8_t) uint8 {
	return uint8(value)
}

func (FfiConverteruint8) read(reader io.Reader) uint8 {
	return readUint8(reader)
}

type FfiDestroyeruint8 struct{}

func (FfiDestroyeruint8) destroy(_ uint8) {}

type FfiConverteruint16 struct{}

var FfiConverteruint16INSTANCE = FfiConverteruint16{}

func (FfiConverteruint16) lower(value uint16) C.uint16_t {
	return C.uint16_t(value)
}

func (FfiConverteruint16) write(writer io.Writer, value uint16) {
	writeUint16(writer, value)
}

func (FfiConverteruint16) lift(value C.uint16_t) uint16 {
	return uint16(value)
}

func (FfiConverteruint16) read(reader io.Reader) uint16 {
	return readUint16(reader)
}

type FfiDestroyeruint16 struct{}

func (FfiDestroyeruint16) destroy(_ uint16) {}

type FfiConverteruint32 struct{}

var FfiConverteruint32INSTANCE = FfiConverteruint32{}

func (FfiConverteruint32) lower(value uint32) C.uint32_t {
	return C.uint32_t(value)
}

func (FfiConverteruint32) write(writer io.Writer, value uint32) {
	writeUint32(writer, value)
}

func (FfiConverteruint32) lift(value C.uint32_t) uint32 {
	return uint32(value)
}

func (FfiConverteruint32) read(reader io.Reader) uint32 {
	return readUint32(reader)
}

type FfiDestroyeruint32 struct{}

func (FfiDestroyeruint32) destroy(_ uint32) {}

type FfiConverteruint64 struct{}

var FfiConverteruint64INSTANCE = FfiConverteruint64{}

func (FfiConverteruint64) lower(value uint64) C.uint64_t {
	return C.uint64_t(value)
}

func (FfiConverteruint64) write(writer io.Writer, value uint64) {
	writeUint64(writer, value)
}

func (FfiConverteruint64) lift(value C.uint64_t) uint64 {
	return uint64(value)
}

func (FfiConverteruint64) read(reader io.Reader) uint64 {
	return readUint64(reader)
}

type FfiDestroyeruint64 struct{}

func (FfiDestroyeruint64) destroy(_ uint64) {}

type FfiConverterbool struct{}

var FfiConverterboolINSTANCE = FfiConverterbool{}

func (FfiConverterbool) lower(value bool) C.int8_t {
	if value {
		return C.int8_t(1)
	}
	return C.int8_t(0)
}

func (FfiConverterbool) write(writer io.Writer, value bool) {
	if value {
		writeInt8(writer, 1)
	} else {
		writeInt8(writer, 0)
	}
}

func (FfiConverterbool) lift(value C.int8_t) bool {
	return value != 0
}

func (FfiConverterbool) read(reader io.Reader) bool {
	return readInt8(reader) != 0
}

type FfiDestroyerbool struct{}

func (FfiDestroyerbool) destroy(_ bool) {}

type FfiConverterstring struct{}

var FfiConverterstringINSTANCE = FfiConverterstring{}

func (FfiConverterstring) lift(cRustBuf C.RustBuffer) string {
	rustBuf := fromCRustBuffer(cRustBuf)
	defer rustBuf.free()

	reader := rustBuf.asReader()
	b, err := io.ReadAll(reader)
	if err != nil {
		panic(fmt.Errorf("reading reader: %w", err))
	}
	return string(b)
}

func (FfiConverterstring) read(reader io.Reader) string {
	length := readInt32(reader)
	buffer := make([]byte, length)
	read_length, err := reader.Read(buffer)
	if err != nil {
		panic(err)
	}
	if read_length != int(length) {
		panic(fmt.Errorf("bad read length when reading string, expected %d, read %d", length, read_length))
	}
	return string(buffer)
}

func (FfiConverterstring) lower(value string) C.RustBuffer {
	return stringToCRustBuffer(value)
}

func (FfiConverterstring) write(writer io.Writer, value string) {
	if len(value) > math.MaxInt32 {
		panic("String is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	write_length, err := io.WriteString(writer, value)
	if err != nil {
		panic(err)
	}
	if write_length != len(value) {
		panic(fmt.Errorf("bad write length when writing string, expected %d, written %d", len(value), write_length))
	}
}

type FfiDestroyerstring struct{}

func (FfiDestroyerstring) destroy(_ string) {}

// Below is an implementation of synchronization requirements outlined in the link.
// https://github.com/mozilla/uniffi-rs/blob/0dc031132d9493ca812c3af6e7dd60ad2ea95bf0/uniffi_bindgen/src/bindings/kotlin/templates/ObjectRuntime.kt#L31

type FfiObject struct {
	pointer      unsafe.Pointer
	callCounter  atomic.Int64
	freeFunction func(unsafe.Pointer, *C.RustCallStatus)
	destroyed    atomic.Bool
}

func newFfiObject(pointer unsafe.Pointer, freeFunction func(unsafe.Pointer, *C.RustCallStatus)) FfiObject {
	return FfiObject{
		pointer:      pointer,
		freeFunction: freeFunction,
	}
}

func (ffiObject *FfiObject) incrementPointer(debugName string) unsafe.Pointer {
	for {
		counter := ffiObject.callCounter.Load()
		if counter <= -1 {
			panic(fmt.Errorf("%v object has already been destroyed", debugName))
		}
		if counter == math.MaxInt64 {
			panic(fmt.Errorf("%v object call counter would overflow", debugName))
		}
		if ffiObject.callCounter.CompareAndSwap(counter, counter+1) {
			break
		}
	}

	return ffiObject.pointer
}

func (ffiObject *FfiObject) decrementPointer() {
	if ffiObject.callCounter.Add(-1) == -1 {
		ffiObject.freeRustArcPtr()
	}
}

func (ffiObject *FfiObject) destroy() {
	if ffiObject.destroyed.CompareAndSwap(false, true) {
		if ffiObject.callCounter.Add(-1) == -1 {
			ffiObject.freeRustArcPtr()
		}
	}
}

func (ffiObject *FfiObject) freeRustArcPtr() {
	rustCall(func(status *C.RustCallStatus) int32 {
		ffiObject.freeFunction(ffiObject.pointer, status)
		return 0
	})
}

type Builder struct {
	ffiObject FfiObject
}

func NewBuilder() *Builder {

	return FfiConverterBuilderINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.ldk_node_cc4c_Builder_new(_uniffiStatus)
	}))

}

func BuilderFromConfig(config Config) *Builder {

	return FfiConverterBuilderINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.ldk_node_cc4c_Builder_from_config(FfiConverterTypeConfigINSTANCE.lower(config), _uniffiStatus)
	}))

}

func (_self *Builder) SetEntropySeedPath(seedPath string) {
	_pointer := _self.ffiObject.incrementPointer("*Builder")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_Builder_set_entropy_seed_path(
			_pointer, FfiConverterstringINSTANCE.lower(seedPath), _uniffiStatus)
		return false
	})

}
func (_self *Builder) SetEntropySeedBytes(seedBytes []uint8) error {
	_pointer := _self.ffiObject.incrementPointer("*Builder")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeBuildError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_Builder_set_entropy_seed_bytes(
			_pointer, FfiConverterSequenceuint8INSTANCE.lower(seedBytes), _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *Builder) SetEntropyBip39Mnemonic(mnemonic Mnemonic, passphrase *string) {
	_pointer := _self.ffiObject.incrementPointer("*Builder")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_Builder_set_entropy_bip39_mnemonic(
			_pointer, FfiConverterTypeMnemonicINSTANCE.lower(mnemonic), FfiConverterOptionalstringINSTANCE.lower(passphrase), _uniffiStatus)
		return false
	})

}
func (_self *Builder) SetEsploraServer(esploraServerUrl string) {
	_pointer := _self.ffiObject.incrementPointer("*Builder")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_Builder_set_esplora_server(
			_pointer, FfiConverterstringINSTANCE.lower(esploraServerUrl), _uniffiStatus)
		return false
	})

}
func (_self *Builder) SetGossipSourceP2p() {
	_pointer := _self.ffiObject.incrementPointer("*Builder")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_Builder_set_gossip_source_p2p(
			_pointer, _uniffiStatus)
		return false
	})

}
func (_self *Builder) SetGossipSourceRgs(rgsServerUrl string) {
	_pointer := _self.ffiObject.incrementPointer("*Builder")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_Builder_set_gossip_source_rgs(
			_pointer, FfiConverterstringINSTANCE.lower(rgsServerUrl), _uniffiStatus)
		return false
	})

}
func (_self *Builder) SetStorageDirPath(storageDirPath string) {
	_pointer := _self.ffiObject.incrementPointer("*Builder")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_Builder_set_storage_dir_path(
			_pointer, FfiConverterstringINSTANCE.lower(storageDirPath), _uniffiStatus)
		return false
	})

}
func (_self *Builder) SetNetwork(network Network) {
	_pointer := _self.ffiObject.incrementPointer("*Builder")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_Builder_set_network(
			_pointer, FfiConverterTypeNetworkINSTANCE.lower(network), _uniffiStatus)
		return false
	})

}
func (_self *Builder) SetListeningAddress(listeningAddress NetAddress) {
	_pointer := _self.ffiObject.incrementPointer("*Builder")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_Builder_set_listening_address(
			_pointer, FfiConverterTypeNetAddressINSTANCE.lower(listeningAddress), _uniffiStatus)
		return false
	})

}
func (_self *Builder) Build() (*LDKNode, error) {
	_pointer := _self.ffiObject.incrementPointer("*Builder")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeBuildError{}, func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.ldk_node_cc4c_Builder_build(
			_pointer, _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue *LDKNode
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterLDKNodeINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}

func (object *Builder) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterBuilder struct{}

var FfiConverterBuilderINSTANCE = FfiConverterBuilder{}

func (c FfiConverterBuilder) lift(pointer unsafe.Pointer) *Builder {
	result := &Builder{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.ffi_ldk_node_cc4c_Builder_object_free(pointer, status)
			}),
	}
	runtime.SetFinalizer(result, (*Builder).Destroy)
	return result
}

func (c FfiConverterBuilder) read(reader io.Reader) *Builder {
	return c.lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterBuilder) lower(value *Builder) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*Builder")
	defer value.ffiObject.decrementPointer()
	return pointer
}

func (c FfiConverterBuilder) write(writer io.Writer, value *Builder) {
	writeUint64(writer, uint64(uintptr(c.lower(value))))
}

type FfiDestroyerBuilder struct{}

func (_ FfiDestroyerBuilder) destroy(value *Builder) {
	value.Destroy()
}

type ChannelConfig struct {
	ffiObject FfiObject
}

func NewChannelConfig() *ChannelConfig {

	return FfiConverterChannelConfigINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) unsafe.Pointer {
		return C.ldk_node_cc4c_ChannelConfig_new(_uniffiStatus)
	}))

}

func (_self *ChannelConfig) ForwardingFeeProportionalMillionths() uint32 {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	return FfiConverteruint32INSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint32_t {
		return C.ldk_node_cc4c_ChannelConfig_forwarding_fee_proportional_millionths(
			_pointer, _uniffiStatus)
	}))

}
func (_self *ChannelConfig) SetForwardingFeeProportionalMillionths(value uint32) {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_ChannelConfig_set_forwarding_fee_proportional_millionths(
			_pointer, FfiConverteruint32INSTANCE.lower(value), _uniffiStatus)
		return false
	})

}
func (_self *ChannelConfig) ForwardingFeeBaseMsat() uint32 {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	return FfiConverteruint32INSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint32_t {
		return C.ldk_node_cc4c_ChannelConfig_forwarding_fee_base_msat(
			_pointer, _uniffiStatus)
	}))

}
func (_self *ChannelConfig) SetForwardingFeeBaseMsat(feeMsat uint32) {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_ChannelConfig_set_forwarding_fee_base_msat(
			_pointer, FfiConverteruint32INSTANCE.lower(feeMsat), _uniffiStatus)
		return false
	})

}
func (_self *ChannelConfig) CltvExpiryDelta() uint16 {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	return FfiConverteruint16INSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint16_t {
		return C.ldk_node_cc4c_ChannelConfig_cltv_expiry_delta(
			_pointer, _uniffiStatus)
	}))

}
func (_self *ChannelConfig) SetCltvExpiryDelta(value uint16) {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_ChannelConfig_set_cltv_expiry_delta(
			_pointer, FfiConverteruint16INSTANCE.lower(value), _uniffiStatus)
		return false
	})

}
func (_self *ChannelConfig) ForceCloseAvoidanceMaxFeeSatoshis() uint64 {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	return FfiConverteruint64INSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.ldk_node_cc4c_ChannelConfig_force_close_avoidance_max_fee_satoshis(
			_pointer, _uniffiStatus)
	}))

}
func (_self *ChannelConfig) SetForceCloseAvoidanceMaxFeeSatoshis(valueSat uint64) {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_ChannelConfig_set_force_close_avoidance_max_fee_satoshis(
			_pointer, FfiConverteruint64INSTANCE.lower(valueSat), _uniffiStatus)
		return false
	})

}
func (_self *ChannelConfig) AcceptUnderpayingHtlcs() bool {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterboolINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.ldk_node_cc4c_ChannelConfig_accept_underpaying_htlcs(
			_pointer, _uniffiStatus)
	}))

}
func (_self *ChannelConfig) SetAcceptUnderpayingHtlcs(value bool) {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_ChannelConfig_set_accept_underpaying_htlcs(
			_pointer, FfiConverterboolINSTANCE.lower(value), _uniffiStatus)
		return false
	})

}
func (_self *ChannelConfig) SetMaxDustHtlcExposureFromFixedLimit(limitMsat uint64) {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_ChannelConfig_set_max_dust_htlc_exposure_from_fixed_limit(
			_pointer, FfiConverteruint64INSTANCE.lower(limitMsat), _uniffiStatus)
		return false
	})

}
func (_self *ChannelConfig) SetMaxDustHtlcExposureFromFeeRateMultiplier(multiplier uint64) {
	_pointer := _self.ffiObject.incrementPointer("*ChannelConfig")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_ChannelConfig_set_max_dust_htlc_exposure_from_fee_rate_multiplier(
			_pointer, FfiConverteruint64INSTANCE.lower(multiplier), _uniffiStatus)
		return false
	})

}

func (object *ChannelConfig) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterChannelConfig struct{}

var FfiConverterChannelConfigINSTANCE = FfiConverterChannelConfig{}

func (c FfiConverterChannelConfig) lift(pointer unsafe.Pointer) *ChannelConfig {
	result := &ChannelConfig{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.ffi_ldk_node_cc4c_ChannelConfig_object_free(pointer, status)
			}),
	}
	runtime.SetFinalizer(result, (*ChannelConfig).Destroy)
	return result
}

func (c FfiConverterChannelConfig) read(reader io.Reader) *ChannelConfig {
	return c.lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterChannelConfig) lower(value *ChannelConfig) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*ChannelConfig")
	defer value.ffiObject.decrementPointer()
	return pointer
}

func (c FfiConverterChannelConfig) write(writer io.Writer, value *ChannelConfig) {
	writeUint64(writer, uint64(uintptr(c.lower(value))))
}

type FfiDestroyerChannelConfig struct{}

func (_ FfiDestroyerChannelConfig) destroy(value *ChannelConfig) {
	value.Destroy()
}

type LDKNode struct {
	ffiObject FfiObject
}

func (_self *LDKNode) Start() error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_start(
			_pointer, _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) Stop() error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_stop(
			_pointer, _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) NextEvent() *Event {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterOptionalTypeEventINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_next_event(
			_pointer, _uniffiStatus)
	}))

}
func (_self *LDKNode) WaitNextEvent() Event {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterTypeEventINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_wait_next_event(
			_pointer, _uniffiStatus)
	}))

}
func (_self *LDKNode) EventHandled() {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	rustCall(func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_event_handled(
			_pointer, _uniffiStatus)
		return false
	})

}
func (_self *LDKNode) NodeId() PublicKey {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterTypePublicKeyINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_node_id(
			_pointer, _uniffiStatus)
	}))

}
func (_self *LDKNode) ListeningAddress() *NetAddress {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterOptionalTypeNetAddressINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_listening_address(
			_pointer, _uniffiStatus)
	}))

}
func (_self *LDKNode) NewOnchainAddress() (Address, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_new_onchain_address(
			_pointer, _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue Address
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterTypeAddressINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) SendToOnchainAddress(address Address, amountMsat uint64) (Txid, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_send_to_onchain_address(
			_pointer, FfiConverterTypeAddressINSTANCE.lower(address), FfiConverteruint64INSTANCE.lower(amountMsat), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue Txid
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterTypeTxidINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) SendAllToOnchainAddress(address Address) (Txid, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_send_all_to_onchain_address(
			_pointer, FfiConverterTypeAddressINSTANCE.lower(address), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue Txid
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterTypeTxidINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) SpendableOnchainBalanceSats() (uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.ldk_node_cc4c_LDKNode_spendable_onchain_balance_sats(
			_pointer, _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue uint64
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverteruint64INSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) TotalOnchainBalanceSats() (uint64, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.uint64_t {
		return C.ldk_node_cc4c_LDKNode_total_onchain_balance_sats(
			_pointer, _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue uint64
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverteruint64INSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) Connect(nodeId PublicKey, address NetAddress, persist bool) error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_connect(
			_pointer, FfiConverterTypePublicKeyINSTANCE.lower(nodeId), FfiConverterTypeNetAddressINSTANCE.lower(address), FfiConverterboolINSTANCE.lower(persist), _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) Disconnect(nodeId PublicKey) error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_disconnect(
			_pointer, FfiConverterTypePublicKeyINSTANCE.lower(nodeId), _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) ConnectOpenChannel(nodeId PublicKey, address NetAddress, channelAmountSats uint64, pushToCounterpartyMsat *uint64, channelConfig **ChannelConfig, announceChannel bool) error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_connect_open_channel(
			_pointer, FfiConverterTypePublicKeyINSTANCE.lower(nodeId), FfiConverterTypeNetAddressINSTANCE.lower(address), FfiConverteruint64INSTANCE.lower(channelAmountSats), FfiConverterOptionaluint64INSTANCE.lower(pushToCounterpartyMsat), FfiConverterOptionalChannelConfigINSTANCE.lower(channelConfig), FfiConverterboolINSTANCE.lower(announceChannel), _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) CloseChannel(channelId ChannelId, counterpartyNodeId PublicKey) error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_close_channel(
			_pointer, FfiConverterTypeChannelIdINSTANCE.lower(channelId), FfiConverterTypePublicKeyINSTANCE.lower(counterpartyNodeId), _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) UpdateChannelConfig(channelId ChannelId, counterpartyNodeId PublicKey, channelConfig *ChannelConfig) error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_update_channel_config(
			_pointer, FfiConverterTypeChannelIdINSTANCE.lower(channelId), FfiConverterTypePublicKeyINSTANCE.lower(counterpartyNodeId), FfiConverterChannelConfigINSTANCE.lower(channelConfig), _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) SyncWallets() error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_sync_wallets(
			_pointer, _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) SendPayment(invoice Bolt11Invoice) (PaymentHash, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_send_payment(
			_pointer, FfiConverterTypeBolt11InvoiceINSTANCE.lower(invoice), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue PaymentHash
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterTypePaymentHashINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) SendPaymentUsingAmount(invoice Bolt11Invoice, amountMsat uint64) (PaymentHash, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_send_payment_using_amount(
			_pointer, FfiConverterTypeBolt11InvoiceINSTANCE.lower(invoice), FfiConverteruint64INSTANCE.lower(amountMsat), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue PaymentHash
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterTypePaymentHashINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) SendSpontaneousPayment(amountMsat uint64, nodeId PublicKey) (PaymentHash, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_send_spontaneous_payment(
			_pointer, FfiConverteruint64INSTANCE.lower(amountMsat), FfiConverterTypePublicKeyINSTANCE.lower(nodeId), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue PaymentHash
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterTypePaymentHashINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) SendPaymentProbe(invoice Bolt11Invoice) error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_send_payment_probe(
			_pointer, FfiConverterTypeBolt11InvoiceINSTANCE.lower(invoice), _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) SendSpontaneousPaymentProbe(amountMsat uint64, nodeId PublicKey) error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_send_spontaneous_payment_probe(
			_pointer, FfiConverteruint64INSTANCE.lower(amountMsat), FfiConverterTypePublicKeyINSTANCE.lower(nodeId), _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) ReceivePayment(amountMsat uint64, description string, expirySecs uint32) (Bolt11Invoice, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_receive_payment(
			_pointer, FfiConverteruint64INSTANCE.lower(amountMsat), FfiConverterstringINSTANCE.lower(description), FfiConverteruint32INSTANCE.lower(expirySecs), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue Bolt11Invoice
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterTypeBolt11InvoiceINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) ReceiveVariableAmountPayment(description string, expirySecs uint32) (Bolt11Invoice, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_receive_variable_amount_payment(
			_pointer, FfiConverterstringINSTANCE.lower(description), FfiConverteruint32INSTANCE.lower(expirySecs), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue Bolt11Invoice
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterTypeBolt11InvoiceINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) Payment(paymentHash PaymentHash) *PaymentDetails {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterOptionalTypePaymentDetailsINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_payment(
			_pointer, FfiConverterTypePaymentHashINSTANCE.lower(paymentHash), _uniffiStatus)
	}))

}
func (_self *LDKNode) RemovePayment(paymentHash PaymentHash) error {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) bool {
		C.ldk_node_cc4c_LDKNode_remove_payment(
			_pointer, FfiConverterTypePaymentHashINSTANCE.lower(paymentHash), _uniffiStatus)
		return false
	})
	return _uniffiErr

}
func (_self *LDKNode) ListPayments() []PaymentDetails {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterSequenceTypePaymentDetailsINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_list_payments(
			_pointer, _uniffiStatus)
	}))

}
func (_self *LDKNode) ListPeers() []PeerDetails {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterSequenceTypePeerDetailsINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_list_peers(
			_pointer, _uniffiStatus)
	}))

}
func (_self *LDKNode) ListChannels() []ChannelDetails {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterSequenceTypeChannelDetailsINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_list_channels(
			_pointer, _uniffiStatus)
	}))

}
func (_self *LDKNode) SignMessage(msg []uint8) (string, error) {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	_uniffiRV, _uniffiErr := rustCallWithError(FfiConverterTypeNodeError{}, func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_LDKNode_sign_message(
			_pointer, FfiConverterSequenceuint8INSTANCE.lower(msg), _uniffiStatus)
	})
	if _uniffiErr != nil {
		var _uniffiDefaultValue string
		return _uniffiDefaultValue, _uniffiErr
	} else {
		return FfiConverterstringINSTANCE.lift(_uniffiRV), _uniffiErr
	}

}
func (_self *LDKNode) VerifySignature(msg []uint8, sig string, pkey PublicKey) bool {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterboolINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.ldk_node_cc4c_LDKNode_verify_signature(
			_pointer, FfiConverterSequenceuint8INSTANCE.lower(msg), FfiConverterstringINSTANCE.lower(sig), FfiConverterTypePublicKeyINSTANCE.lower(pkey), _uniffiStatus)
	}))

}
func (_self *LDKNode) IsRunning() bool {
	_pointer := _self.ffiObject.incrementPointer("*LDKNode")
	defer _self.ffiObject.decrementPointer()

	return FfiConverterboolINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.int8_t {
		return C.ldk_node_cc4c_LDKNode_is_running(
			_pointer, _uniffiStatus)
	}))

}

func (object *LDKNode) Destroy() {
	runtime.SetFinalizer(object, nil)
	object.ffiObject.destroy()
}

type FfiConverterLDKNode struct{}

var FfiConverterLDKNodeINSTANCE = FfiConverterLDKNode{}

func (c FfiConverterLDKNode) lift(pointer unsafe.Pointer) *LDKNode {
	result := &LDKNode{
		newFfiObject(
			pointer,
			func(pointer unsafe.Pointer, status *C.RustCallStatus) {
				C.ffi_ldk_node_cc4c_LDKNode_object_free(pointer, status)
			}),
	}
	runtime.SetFinalizer(result, (*LDKNode).Destroy)
	return result
}

func (c FfiConverterLDKNode) read(reader io.Reader) *LDKNode {
	return c.lift(unsafe.Pointer(uintptr(readUint64(reader))))
}

func (c FfiConverterLDKNode) lower(value *LDKNode) unsafe.Pointer {
	// TODO: this is bad - all synchronization from ObjectRuntime.go is discarded here,
	// because the pointer will be decremented immediately after this function returns,
	// and someone will be left holding onto a non-locked pointer.
	pointer := value.ffiObject.incrementPointer("*LDKNode")
	defer value.ffiObject.decrementPointer()
	return pointer
}

func (c FfiConverterLDKNode) write(writer io.Writer, value *LDKNode) {
	writeUint64(writer, uint64(uintptr(c.lower(value))))
}

type FfiDestroyerLDKNode struct{}

func (_ FfiDestroyerLDKNode) destroy(value *LDKNode) {
	value.Destroy()
}

type ChannelDetails struct {
	ChannelId                    ChannelId
	CounterpartyNodeId           PublicKey
	FundingTxo                   *OutPoint
	ChannelValueSats             uint64
	UnspendablePunishmentReserve *uint64
	UserChannelId                UserChannelId
	FeerateSatPer1000Weight      uint32
	BalanceMsat                  uint64
	OutboundCapacityMsat         uint64
	InboundCapacityMsat          uint64
	ConfirmationsRequired        *uint32
	Confirmations                *uint32
	IsOutbound                   bool
	IsChannelReady               bool
	IsUsable                     bool
	IsPublic                     bool
	CltvExpiryDelta              *uint16
}

func (r *ChannelDetails) Destroy() {
	FfiDestroyerTypeChannelId{}.destroy(r.ChannelId)
	FfiDestroyerTypePublicKey{}.destroy(r.CounterpartyNodeId)
	FfiDestroyerOptionalTypeOutPoint{}.destroy(r.FundingTxo)
	FfiDestroyeruint64{}.destroy(r.ChannelValueSats)
	FfiDestroyerOptionaluint64{}.destroy(r.UnspendablePunishmentReserve)
	FfiDestroyerTypeUserChannelId{}.destroy(r.UserChannelId)
	FfiDestroyeruint32{}.destroy(r.FeerateSatPer1000Weight)
	FfiDestroyeruint64{}.destroy(r.BalanceMsat)
	FfiDestroyeruint64{}.destroy(r.OutboundCapacityMsat)
	FfiDestroyeruint64{}.destroy(r.InboundCapacityMsat)
	FfiDestroyerOptionaluint32{}.destroy(r.ConfirmationsRequired)
	FfiDestroyerOptionaluint32{}.destroy(r.Confirmations)
	FfiDestroyerbool{}.destroy(r.IsOutbound)
	FfiDestroyerbool{}.destroy(r.IsChannelReady)
	FfiDestroyerbool{}.destroy(r.IsUsable)
	FfiDestroyerbool{}.destroy(r.IsPublic)
	FfiDestroyerOptionaluint16{}.destroy(r.CltvExpiryDelta)
}

type FfiConverterTypeChannelDetails struct{}

var FfiConverterTypeChannelDetailsINSTANCE = FfiConverterTypeChannelDetails{}

func (c FfiConverterTypeChannelDetails) lift(cRustBuf C.RustBuffer) ChannelDetails {
	rustBuffer := fromCRustBuffer(cRustBuf)
	return liftFromRustBuffer[ChannelDetails](c, rustBuffer)
}

func (c FfiConverterTypeChannelDetails) read(reader io.Reader) ChannelDetails {
	return ChannelDetails{
		FfiConverterTypeChannelIdINSTANCE.read(reader),
		FfiConverterTypePublicKeyINSTANCE.read(reader),
		FfiConverterOptionalTypeOutPointINSTANCE.read(reader),
		FfiConverteruint64INSTANCE.read(reader),
		FfiConverterOptionaluint64INSTANCE.read(reader),
		FfiConverterTypeUserChannelIdINSTANCE.read(reader),
		FfiConverteruint32INSTANCE.read(reader),
		FfiConverteruint64INSTANCE.read(reader),
		FfiConverteruint64INSTANCE.read(reader),
		FfiConverteruint64INSTANCE.read(reader),
		FfiConverterOptionaluint32INSTANCE.read(reader),
		FfiConverterOptionaluint32INSTANCE.read(reader),
		FfiConverterboolINSTANCE.read(reader),
		FfiConverterboolINSTANCE.read(reader),
		FfiConverterboolINSTANCE.read(reader),
		FfiConverterboolINSTANCE.read(reader),
		FfiConverterOptionaluint16INSTANCE.read(reader),
	}
}

func (c FfiConverterTypeChannelDetails) lower(value ChannelDetails) C.RustBuffer {
	return lowerIntoRustBuffer[ChannelDetails](c, value)
}

func (c FfiConverterTypeChannelDetails) write(writer io.Writer, value ChannelDetails) {
	FfiConverterTypeChannelIdINSTANCE.write(writer, value.ChannelId)
	FfiConverterTypePublicKeyINSTANCE.write(writer, value.CounterpartyNodeId)
	FfiConverterOptionalTypeOutPointINSTANCE.write(writer, value.FundingTxo)
	FfiConverteruint64INSTANCE.write(writer, value.ChannelValueSats)
	FfiConverterOptionaluint64INSTANCE.write(writer, value.UnspendablePunishmentReserve)
	FfiConverterTypeUserChannelIdINSTANCE.write(writer, value.UserChannelId)
	FfiConverteruint32INSTANCE.write(writer, value.FeerateSatPer1000Weight)
	FfiConverteruint64INSTANCE.write(writer, value.BalanceMsat)
	FfiConverteruint64INSTANCE.write(writer, value.OutboundCapacityMsat)
	FfiConverteruint64INSTANCE.write(writer, value.InboundCapacityMsat)
	FfiConverterOptionaluint32INSTANCE.write(writer, value.ConfirmationsRequired)
	FfiConverterOptionaluint32INSTANCE.write(writer, value.Confirmations)
	FfiConverterboolINSTANCE.write(writer, value.IsOutbound)
	FfiConverterboolINSTANCE.write(writer, value.IsChannelReady)
	FfiConverterboolINSTANCE.write(writer, value.IsUsable)
	FfiConverterboolINSTANCE.write(writer, value.IsPublic)
	FfiConverterOptionaluint16INSTANCE.write(writer, value.CltvExpiryDelta)
}

type FfiDestroyerTypeChannelDetails struct{}

func (_ FfiDestroyerTypeChannelDetails) destroy(value ChannelDetails) {
	value.Destroy()
}

type Config struct {
	StorageDirPath                  string
	LogDirPath                      *string
	Network                         Network
	ListeningAddress                *NetAddress
	DefaultCltvExpiryDelta          uint32
	OnchainWalletSyncIntervalSecs   uint64
	WalletSyncIntervalSecs          uint64
	FeeRateCacheUpdateIntervalSecs  uint64
	TrustedPeers0conf               []PublicKey
	ProbingLiquidityLimitMultiplier uint64
	LogLevel                        LogLevel
}

func (r *Config) Destroy() {
	FfiDestroyerstring{}.destroy(r.StorageDirPath)
	FfiDestroyerOptionalstring{}.destroy(r.LogDirPath)
	FfiDestroyerTypeNetwork{}.destroy(r.Network)
	FfiDestroyerOptionalTypeNetAddress{}.destroy(r.ListeningAddress)
	FfiDestroyeruint32{}.destroy(r.DefaultCltvExpiryDelta)
	FfiDestroyeruint64{}.destroy(r.OnchainWalletSyncIntervalSecs)
	FfiDestroyeruint64{}.destroy(r.WalletSyncIntervalSecs)
	FfiDestroyeruint64{}.destroy(r.FeeRateCacheUpdateIntervalSecs)
	FfiDestroyerSequenceTypePublicKey{}.destroy(r.TrustedPeers0conf)
	FfiDestroyeruint64{}.destroy(r.ProbingLiquidityLimitMultiplier)
	FfiDestroyerTypeLogLevel{}.destroy(r.LogLevel)
}

type FfiConverterTypeConfig struct{}

var FfiConverterTypeConfigINSTANCE = FfiConverterTypeConfig{}

func (c FfiConverterTypeConfig) lift(cRustBuf C.RustBuffer) Config {
	rustBuffer := fromCRustBuffer(cRustBuf)
	return liftFromRustBuffer[Config](c, rustBuffer)
}

func (c FfiConverterTypeConfig) read(reader io.Reader) Config {
	return Config{
		FfiConverterstringINSTANCE.read(reader),
		FfiConverterOptionalstringINSTANCE.read(reader),
		FfiConverterTypeNetworkINSTANCE.read(reader),
		FfiConverterOptionalTypeNetAddressINSTANCE.read(reader),
		FfiConverteruint32INSTANCE.read(reader),
		FfiConverteruint64INSTANCE.read(reader),
		FfiConverteruint64INSTANCE.read(reader),
		FfiConverteruint64INSTANCE.read(reader),
		FfiConverterSequenceTypePublicKeyINSTANCE.read(reader),
		FfiConverteruint64INSTANCE.read(reader),
		FfiConverterTypeLogLevelINSTANCE.read(reader),
	}
}

func (c FfiConverterTypeConfig) lower(value Config) C.RustBuffer {
	return lowerIntoRustBuffer[Config](c, value)
}

func (c FfiConverterTypeConfig) write(writer io.Writer, value Config) {
	FfiConverterstringINSTANCE.write(writer, value.StorageDirPath)
	FfiConverterOptionalstringINSTANCE.write(writer, value.LogDirPath)
	FfiConverterTypeNetworkINSTANCE.write(writer, value.Network)
	FfiConverterOptionalTypeNetAddressINSTANCE.write(writer, value.ListeningAddress)
	FfiConverteruint32INSTANCE.write(writer, value.DefaultCltvExpiryDelta)
	FfiConverteruint64INSTANCE.write(writer, value.OnchainWalletSyncIntervalSecs)
	FfiConverteruint64INSTANCE.write(writer, value.WalletSyncIntervalSecs)
	FfiConverteruint64INSTANCE.write(writer, value.FeeRateCacheUpdateIntervalSecs)
	FfiConverterSequenceTypePublicKeyINSTANCE.write(writer, value.TrustedPeers0conf)
	FfiConverteruint64INSTANCE.write(writer, value.ProbingLiquidityLimitMultiplier)
	FfiConverterTypeLogLevelINSTANCE.write(writer, value.LogLevel)
}

type FfiDestroyerTypeConfig struct{}

func (_ FfiDestroyerTypeConfig) destroy(value Config) {
	value.Destroy()
}

type OutPoint struct {
	Txid Txid
	Vout uint32
}

func (r *OutPoint) Destroy() {
	FfiDestroyerTypeTxid{}.destroy(r.Txid)
	FfiDestroyeruint32{}.destroy(r.Vout)
}

type FfiConverterTypeOutPoint struct{}

var FfiConverterTypeOutPointINSTANCE = FfiConverterTypeOutPoint{}

func (c FfiConverterTypeOutPoint) lift(cRustBuf C.RustBuffer) OutPoint {
	rustBuffer := fromCRustBuffer(cRustBuf)
	return liftFromRustBuffer[OutPoint](c, rustBuffer)
}

func (c FfiConverterTypeOutPoint) read(reader io.Reader) OutPoint {
	return OutPoint{
		FfiConverterTypeTxidINSTANCE.read(reader),
		FfiConverteruint32INSTANCE.read(reader),
	}
}

func (c FfiConverterTypeOutPoint) lower(value OutPoint) C.RustBuffer {
	return lowerIntoRustBuffer[OutPoint](c, value)
}

func (c FfiConverterTypeOutPoint) write(writer io.Writer, value OutPoint) {
	FfiConverterTypeTxidINSTANCE.write(writer, value.Txid)
	FfiConverteruint32INSTANCE.write(writer, value.Vout)
}

type FfiDestroyerTypeOutPoint struct{}

func (_ FfiDestroyerTypeOutPoint) destroy(value OutPoint) {
	value.Destroy()
}

type PaymentDetails struct {
	Hash       PaymentHash
	Preimage   *PaymentPreimage
	Secret     *PaymentSecret
	AmountMsat *uint64
	Direction  PaymentDirection
	Status     PaymentStatus
}

func (r *PaymentDetails) Destroy() {
	FfiDestroyerTypePaymentHash{}.destroy(r.Hash)
	FfiDestroyerOptionalTypePaymentPreimage{}.destroy(r.Preimage)
	FfiDestroyerOptionalTypePaymentSecret{}.destroy(r.Secret)
	FfiDestroyerOptionaluint64{}.destroy(r.AmountMsat)
	FfiDestroyerTypePaymentDirection{}.destroy(r.Direction)
	FfiDestroyerTypePaymentStatus{}.destroy(r.Status)
}

type FfiConverterTypePaymentDetails struct{}

var FfiConverterTypePaymentDetailsINSTANCE = FfiConverterTypePaymentDetails{}

func (c FfiConverterTypePaymentDetails) lift(cRustBuf C.RustBuffer) PaymentDetails {
	rustBuffer := fromCRustBuffer(cRustBuf)
	return liftFromRustBuffer[PaymentDetails](c, rustBuffer)
}

func (c FfiConverterTypePaymentDetails) read(reader io.Reader) PaymentDetails {
	return PaymentDetails{
		FfiConverterTypePaymentHashINSTANCE.read(reader),
		FfiConverterOptionalTypePaymentPreimageINSTANCE.read(reader),
		FfiConverterOptionalTypePaymentSecretINSTANCE.read(reader),
		FfiConverterOptionaluint64INSTANCE.read(reader),
		FfiConverterTypePaymentDirectionINSTANCE.read(reader),
		FfiConverterTypePaymentStatusINSTANCE.read(reader),
	}
}

func (c FfiConverterTypePaymentDetails) lower(value PaymentDetails) C.RustBuffer {
	return lowerIntoRustBuffer[PaymentDetails](c, value)
}

func (c FfiConverterTypePaymentDetails) write(writer io.Writer, value PaymentDetails) {
	FfiConverterTypePaymentHashINSTANCE.write(writer, value.Hash)
	FfiConverterOptionalTypePaymentPreimageINSTANCE.write(writer, value.Preimage)
	FfiConverterOptionalTypePaymentSecretINSTANCE.write(writer, value.Secret)
	FfiConverterOptionaluint64INSTANCE.write(writer, value.AmountMsat)
	FfiConverterTypePaymentDirectionINSTANCE.write(writer, value.Direction)
	FfiConverterTypePaymentStatusINSTANCE.write(writer, value.Status)
}

type FfiDestroyerTypePaymentDetails struct{}

func (_ FfiDestroyerTypePaymentDetails) destroy(value PaymentDetails) {
	value.Destroy()
}

type PeerDetails struct {
	NodeId      PublicKey
	Address     NetAddress
	IsPersisted bool
	IsConnected bool
}

func (r *PeerDetails) Destroy() {
	FfiDestroyerTypePublicKey{}.destroy(r.NodeId)
	FfiDestroyerTypeNetAddress{}.destroy(r.Address)
	FfiDestroyerbool{}.destroy(r.IsPersisted)
	FfiDestroyerbool{}.destroy(r.IsConnected)
}

type FfiConverterTypePeerDetails struct{}

var FfiConverterTypePeerDetailsINSTANCE = FfiConverterTypePeerDetails{}

func (c FfiConverterTypePeerDetails) lift(cRustBuf C.RustBuffer) PeerDetails {
	rustBuffer := fromCRustBuffer(cRustBuf)
	return liftFromRustBuffer[PeerDetails](c, rustBuffer)
}

func (c FfiConverterTypePeerDetails) read(reader io.Reader) PeerDetails {
	return PeerDetails{
		FfiConverterTypePublicKeyINSTANCE.read(reader),
		FfiConverterTypeNetAddressINSTANCE.read(reader),
		FfiConverterboolINSTANCE.read(reader),
		FfiConverterboolINSTANCE.read(reader),
	}
}

func (c FfiConverterTypePeerDetails) lower(value PeerDetails) C.RustBuffer {
	return lowerIntoRustBuffer[PeerDetails](c, value)
}

func (c FfiConverterTypePeerDetails) write(writer io.Writer, value PeerDetails) {
	FfiConverterTypePublicKeyINSTANCE.write(writer, value.NodeId)
	FfiConverterTypeNetAddressINSTANCE.write(writer, value.Address)
	FfiConverterboolINSTANCE.write(writer, value.IsPersisted)
	FfiConverterboolINSTANCE.write(writer, value.IsConnected)
}

type FfiDestroyerTypePeerDetails struct{}

func (_ FfiDestroyerTypePeerDetails) destroy(value PeerDetails) {
	value.Destroy()
}

type Event interface {
	Destroy()
}
type EventPaymentSuccessful struct {
	PaymentHash PaymentHash
}

func (e EventPaymentSuccessful) Destroy() {
	FfiDestroyerTypePaymentHash{}.destroy(e.PaymentHash)
}

type EventPaymentFailed struct {
	PaymentHash PaymentHash
}

func (e EventPaymentFailed) Destroy() {
	FfiDestroyerTypePaymentHash{}.destroy(e.PaymentHash)
}

type EventPaymentReceived struct {
	PaymentHash PaymentHash
	AmountMsat  uint64
}

func (e EventPaymentReceived) Destroy() {
	FfiDestroyerTypePaymentHash{}.destroy(e.PaymentHash)
	FfiDestroyeruint64{}.destroy(e.AmountMsat)
}

type EventChannelPending struct {
	ChannelId                ChannelId
	UserChannelId            UserChannelId
	FormerTemporaryChannelId ChannelId
	CounterpartyNodeId       PublicKey
	FundingTxo               OutPoint
}

func (e EventChannelPending) Destroy() {
	FfiDestroyerTypeChannelId{}.destroy(e.ChannelId)
	FfiDestroyerTypeUserChannelId{}.destroy(e.UserChannelId)
	FfiDestroyerTypeChannelId{}.destroy(e.FormerTemporaryChannelId)
	FfiDestroyerTypePublicKey{}.destroy(e.CounterpartyNodeId)
	FfiDestroyerTypeOutPoint{}.destroy(e.FundingTxo)
}

type EventChannelReady struct {
	ChannelId     ChannelId
	UserChannelId UserChannelId
}

func (e EventChannelReady) Destroy() {
	FfiDestroyerTypeChannelId{}.destroy(e.ChannelId)
	FfiDestroyerTypeUserChannelId{}.destroy(e.UserChannelId)
}

type EventChannelClosed struct {
	ChannelId     ChannelId
	UserChannelId UserChannelId
}

func (e EventChannelClosed) Destroy() {
	FfiDestroyerTypeChannelId{}.destroy(e.ChannelId)
	FfiDestroyerTypeUserChannelId{}.destroy(e.UserChannelId)
}

type FfiConverterTypeEvent struct{}

var FfiConverterTypeEventINSTANCE = FfiConverterTypeEvent{}

func (c FfiConverterTypeEvent) lift(cRustBuf C.RustBuffer) Event {
	return liftFromRustBuffer[Event](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterTypeEvent) lower(value Event) C.RustBuffer {
	return lowerIntoRustBuffer[Event](c, value)
}
func (FfiConverterTypeEvent) read(reader io.Reader) Event {
	id := readInt32(reader)
	switch id {
	case 1:
		return EventPaymentSuccessful{
			FfiConverterTypePaymentHashINSTANCE.read(reader),
		}
	case 2:
		return EventPaymentFailed{
			FfiConverterTypePaymentHashINSTANCE.read(reader),
		}
	case 3:
		return EventPaymentReceived{
			FfiConverterTypePaymentHashINSTANCE.read(reader),
			FfiConverteruint64INSTANCE.read(reader),
		}
	case 4:
		return EventChannelPending{
			FfiConverterTypeChannelIdINSTANCE.read(reader),
			FfiConverterTypeUserChannelIdINSTANCE.read(reader),
			FfiConverterTypeChannelIdINSTANCE.read(reader),
			FfiConverterTypePublicKeyINSTANCE.read(reader),
			FfiConverterTypeOutPointINSTANCE.read(reader),
		}
	case 5:
		return EventChannelReady{
			FfiConverterTypeChannelIdINSTANCE.read(reader),
			FfiConverterTypeUserChannelIdINSTANCE.read(reader),
		}
	case 6:
		return EventChannelClosed{
			FfiConverterTypeChannelIdINSTANCE.read(reader),
			FfiConverterTypeUserChannelIdINSTANCE.read(reader),
		}
	default:
		panic(fmt.Sprintf("invalid enum value %v in FfiConverterTypeEvent.read()", id))
	}
}

func (FfiConverterTypeEvent) write(writer io.Writer, value Event) {
	switch variant_value := value.(type) {
	case EventPaymentSuccessful:
		writeInt32(writer, 1)
		FfiConverterTypePaymentHashINSTANCE.write(writer, variant_value.PaymentHash)
	case EventPaymentFailed:
		writeInt32(writer, 2)
		FfiConverterTypePaymentHashINSTANCE.write(writer, variant_value.PaymentHash)
	case EventPaymentReceived:
		writeInt32(writer, 3)
		FfiConverterTypePaymentHashINSTANCE.write(writer, variant_value.PaymentHash)
		FfiConverteruint64INSTANCE.write(writer, variant_value.AmountMsat)
	case EventChannelPending:
		writeInt32(writer, 4)
		FfiConverterTypeChannelIdINSTANCE.write(writer, variant_value.ChannelId)
		FfiConverterTypeUserChannelIdINSTANCE.write(writer, variant_value.UserChannelId)
		FfiConverterTypeChannelIdINSTANCE.write(writer, variant_value.FormerTemporaryChannelId)
		FfiConverterTypePublicKeyINSTANCE.write(writer, variant_value.CounterpartyNodeId)
		FfiConverterTypeOutPointINSTANCE.write(writer, variant_value.FundingTxo)
	case EventChannelReady:
		writeInt32(writer, 5)
		FfiConverterTypeChannelIdINSTANCE.write(writer, variant_value.ChannelId)
		FfiConverterTypeUserChannelIdINSTANCE.write(writer, variant_value.UserChannelId)
	case EventChannelClosed:
		writeInt32(writer, 6)
		FfiConverterTypeChannelIdINSTANCE.write(writer, variant_value.ChannelId)
		FfiConverterTypeUserChannelIdINSTANCE.write(writer, variant_value.UserChannelId)
	default:
		_ = variant_value
		panic(fmt.Sprintf("invalid enum value `%v` in FfiConverterTypeEvent.write", value))
	}
}

type FfiDestroyerTypeEvent struct{}

func (_ FfiDestroyerTypeEvent) destroy(value Event) {
	value.Destroy()
}

type LogLevel uint

const (
	LogLevelGossip LogLevel = 1
	LogLevelTrace  LogLevel = 2
	LogLevelDebug  LogLevel = 3
	LogLevelInfo   LogLevel = 4
	LogLevelWarn   LogLevel = 5
	LogLevelError  LogLevel = 6
)

type FfiConverterTypeLogLevel struct{}

var FfiConverterTypeLogLevelINSTANCE = FfiConverterTypeLogLevel{}

func (c FfiConverterTypeLogLevel) lift(cRustBuf C.RustBuffer) LogLevel {
	return liftFromRustBuffer[LogLevel](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterTypeLogLevel) lower(value LogLevel) C.RustBuffer {
	return lowerIntoRustBuffer[LogLevel](c, value)
}
func (FfiConverterTypeLogLevel) read(reader io.Reader) LogLevel {
	id := readInt32(reader)
	return LogLevel(id)
}

func (FfiConverterTypeLogLevel) write(writer io.Writer, value LogLevel) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerTypeLogLevel struct{}

func (_ FfiDestroyerTypeLogLevel) destroy(value LogLevel) {
}

type Network uint

const (
	NetworkBitcoin Network = 1
	NetworkTestnet Network = 2
	NetworkSignet  Network = 3
	NetworkRegtest Network = 4
)

type FfiConverterTypeNetwork struct{}

var FfiConverterTypeNetworkINSTANCE = FfiConverterTypeNetwork{}

func (c FfiConverterTypeNetwork) lift(cRustBuf C.RustBuffer) Network {
	return liftFromRustBuffer[Network](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterTypeNetwork) lower(value Network) C.RustBuffer {
	return lowerIntoRustBuffer[Network](c, value)
}
func (FfiConverterTypeNetwork) read(reader io.Reader) Network {
	id := readInt32(reader)
	return Network(id)
}

func (FfiConverterTypeNetwork) write(writer io.Writer, value Network) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerTypeNetwork struct{}

func (_ FfiDestroyerTypeNetwork) destroy(value Network) {
}

type PaymentDirection uint

const (
	PaymentDirectionInbound  PaymentDirection = 1
	PaymentDirectionOutbound PaymentDirection = 2
)

type FfiConverterTypePaymentDirection struct{}

var FfiConverterTypePaymentDirectionINSTANCE = FfiConverterTypePaymentDirection{}

func (c FfiConverterTypePaymentDirection) lift(cRustBuf C.RustBuffer) PaymentDirection {
	return liftFromRustBuffer[PaymentDirection](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterTypePaymentDirection) lower(value PaymentDirection) C.RustBuffer {
	return lowerIntoRustBuffer[PaymentDirection](c, value)
}
func (FfiConverterTypePaymentDirection) read(reader io.Reader) PaymentDirection {
	id := readInt32(reader)
	return PaymentDirection(id)
}

func (FfiConverterTypePaymentDirection) write(writer io.Writer, value PaymentDirection) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerTypePaymentDirection struct{}

func (_ FfiDestroyerTypePaymentDirection) destroy(value PaymentDirection) {
}

type PaymentStatus uint

const (
	PaymentStatusPending   PaymentStatus = 1
	PaymentStatusSucceeded PaymentStatus = 2
	PaymentStatusFailed    PaymentStatus = 3
)

type FfiConverterTypePaymentStatus struct{}

var FfiConverterTypePaymentStatusINSTANCE = FfiConverterTypePaymentStatus{}

func (c FfiConverterTypePaymentStatus) lift(cRustBuf C.RustBuffer) PaymentStatus {
	return liftFromRustBuffer[PaymentStatus](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterTypePaymentStatus) lower(value PaymentStatus) C.RustBuffer {
	return lowerIntoRustBuffer[PaymentStatus](c, value)
}
func (FfiConverterTypePaymentStatus) read(reader io.Reader) PaymentStatus {
	id := readInt32(reader)
	return PaymentStatus(id)
}

func (FfiConverterTypePaymentStatus) write(writer io.Writer, value PaymentStatus) {
	writeInt32(writer, int32(value))
}

type FfiDestroyerTypePaymentStatus struct{}

func (_ FfiDestroyerTypePaymentStatus) destroy(value PaymentStatus) {
}

type BuildError struct {
	err error
}

func (err BuildError) Error() string {
	return fmt.Sprintf("BuildError: %s", err.err.Error())
}

func (err BuildError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrBuildErrorInvalidSeedBytes = fmt.Errorf("BuildErrorInvalidSeedBytes")
var ErrBuildErrorInvalidSeedFile = fmt.Errorf("BuildErrorInvalidSeedFile")
var ErrBuildErrorInvalidSystemTime = fmt.Errorf("BuildErrorInvalidSystemTime")
var ErrBuildErrorReadFailed = fmt.Errorf("BuildErrorReadFailed")
var ErrBuildErrorWriteFailed = fmt.Errorf("BuildErrorWriteFailed")
var ErrBuildErrorStoragePathAccessFailed = fmt.Errorf("BuildErrorStoragePathAccessFailed")
var ErrBuildErrorWalletSetupFailed = fmt.Errorf("BuildErrorWalletSetupFailed")
var ErrBuildErrorLoggerSetupFailed = fmt.Errorf("BuildErrorLoggerSetupFailed")

// Variant structs
type BuildErrorInvalidSeedBytes struct {
	message string
}

func NewBuildErrorInvalidSeedBytes() *BuildError {
	return &BuildError{
		err: &BuildErrorInvalidSeedBytes{},
	}
}

func (err BuildErrorInvalidSeedBytes) Error() string {
	return fmt.Sprintf("InvalidSeedBytes: %s", err.message)
}

func (self BuildErrorInvalidSeedBytes) Is(target error) bool {
	return target == ErrBuildErrorInvalidSeedBytes
}

type BuildErrorInvalidSeedFile struct {
	message string
}

func NewBuildErrorInvalidSeedFile() *BuildError {
	return &BuildError{
		err: &BuildErrorInvalidSeedFile{},
	}
}

func (err BuildErrorInvalidSeedFile) Error() string {
	return fmt.Sprintf("InvalidSeedFile: %s", err.message)
}

func (self BuildErrorInvalidSeedFile) Is(target error) bool {
	return target == ErrBuildErrorInvalidSeedFile
}

type BuildErrorInvalidSystemTime struct {
	message string
}

func NewBuildErrorInvalidSystemTime() *BuildError {
	return &BuildError{
		err: &BuildErrorInvalidSystemTime{},
	}
}

func (err BuildErrorInvalidSystemTime) Error() string {
	return fmt.Sprintf("InvalidSystemTime: %s", err.message)
}

func (self BuildErrorInvalidSystemTime) Is(target error) bool {
	return target == ErrBuildErrorInvalidSystemTime
}

type BuildErrorReadFailed struct {
	message string
}

func NewBuildErrorReadFailed() *BuildError {
	return &BuildError{
		err: &BuildErrorReadFailed{},
	}
}

func (err BuildErrorReadFailed) Error() string {
	return fmt.Sprintf("ReadFailed: %s", err.message)
}

func (self BuildErrorReadFailed) Is(target error) bool {
	return target == ErrBuildErrorReadFailed
}

type BuildErrorWriteFailed struct {
	message string
}

func NewBuildErrorWriteFailed() *BuildError {
	return &BuildError{
		err: &BuildErrorWriteFailed{},
	}
}

func (err BuildErrorWriteFailed) Error() string {
	return fmt.Sprintf("WriteFailed: %s", err.message)
}

func (self BuildErrorWriteFailed) Is(target error) bool {
	return target == ErrBuildErrorWriteFailed
}

type BuildErrorStoragePathAccessFailed struct {
	message string
}

func NewBuildErrorStoragePathAccessFailed() *BuildError {
	return &BuildError{
		err: &BuildErrorStoragePathAccessFailed{},
	}
}

func (err BuildErrorStoragePathAccessFailed) Error() string {
	return fmt.Sprintf("StoragePathAccessFailed: %s", err.message)
}

func (self BuildErrorStoragePathAccessFailed) Is(target error) bool {
	return target == ErrBuildErrorStoragePathAccessFailed
}

type BuildErrorWalletSetupFailed struct {
	message string
}

func NewBuildErrorWalletSetupFailed() *BuildError {
	return &BuildError{
		err: &BuildErrorWalletSetupFailed{},
	}
}

func (err BuildErrorWalletSetupFailed) Error() string {
	return fmt.Sprintf("WalletSetupFailed: %s", err.message)
}

func (self BuildErrorWalletSetupFailed) Is(target error) bool {
	return target == ErrBuildErrorWalletSetupFailed
}

type BuildErrorLoggerSetupFailed struct {
	message string
}

func NewBuildErrorLoggerSetupFailed() *BuildError {
	return &BuildError{
		err: &BuildErrorLoggerSetupFailed{},
	}
}

func (err BuildErrorLoggerSetupFailed) Error() string {
	return fmt.Sprintf("LoggerSetupFailed: %s", err.message)
}

func (self BuildErrorLoggerSetupFailed) Is(target error) bool {
	return target == ErrBuildErrorLoggerSetupFailed
}

type FfiConverterTypeBuildError struct{}

var FfiConverterTypeBuildErrorINSTANCE = FfiConverterTypeBuildError{}

func (c FfiConverterTypeBuildError) lift(cErrBuf C.RustBuffer) error {
	errBuf := fromCRustBuffer(cErrBuf)
	return liftFromRustBuffer[error](c, errBuf)
}

func (c FfiConverterTypeBuildError) lower(value *BuildError) C.RustBuffer {
	return lowerIntoRustBuffer[*BuildError](c, value)
}

func (c FfiConverterTypeBuildError) read(reader io.Reader) error {
	errorID := readUint32(reader)

	message := FfiConverterstringINSTANCE.read(reader)
	switch errorID {
	case 1:
		return &BuildError{&BuildErrorInvalidSeedBytes{message}}
	case 2:
		return &BuildError{&BuildErrorInvalidSeedFile{message}}
	case 3:
		return &BuildError{&BuildErrorInvalidSystemTime{message}}
	case 4:
		return &BuildError{&BuildErrorReadFailed{message}}
	case 5:
		return &BuildError{&BuildErrorWriteFailed{message}}
	case 6:
		return &BuildError{&BuildErrorStoragePathAccessFailed{message}}
	case 7:
		return &BuildError{&BuildErrorWalletSetupFailed{message}}
	case 8:
		return &BuildError{&BuildErrorLoggerSetupFailed{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterTypeBuildError.read()", errorID))
	}

}

func (c FfiConverterTypeBuildError) write(writer io.Writer, value *BuildError) {
	switch variantValue := value.err.(type) {
	case *BuildErrorInvalidSeedBytes:
		writeInt32(writer, 1)
	case *BuildErrorInvalidSeedFile:
		writeInt32(writer, 2)
	case *BuildErrorInvalidSystemTime:
		writeInt32(writer, 3)
	case *BuildErrorReadFailed:
		writeInt32(writer, 4)
	case *BuildErrorWriteFailed:
		writeInt32(writer, 5)
	case *BuildErrorStoragePathAccessFailed:
		writeInt32(writer, 6)
	case *BuildErrorWalletSetupFailed:
		writeInt32(writer, 7)
	case *BuildErrorLoggerSetupFailed:
		writeInt32(writer, 8)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterTypeBuildError.write", value))
	}
}

type NodeError struct {
	err error
}

func (err NodeError) Error() string {
	return fmt.Sprintf("NodeError: %s", err.err.Error())
}

func (err NodeError) Unwrap() error {
	return err.err
}

// Err* are used for checking error type with `errors.Is`
var ErrNodeErrorAlreadyRunning = fmt.Errorf("NodeErrorAlreadyRunning")
var ErrNodeErrorNotRunning = fmt.Errorf("NodeErrorNotRunning")
var ErrNodeErrorOnchainTxCreationFailed = fmt.Errorf("NodeErrorOnchainTxCreationFailed")
var ErrNodeErrorConnectionFailed = fmt.Errorf("NodeErrorConnectionFailed")
var ErrNodeErrorInvoiceCreationFailed = fmt.Errorf("NodeErrorInvoiceCreationFailed")
var ErrNodeErrorPaymentSendingFailed = fmt.Errorf("NodeErrorPaymentSendingFailed")
var ErrNodeErrorProbeSendingFailed = fmt.Errorf("NodeErrorProbeSendingFailed")
var ErrNodeErrorChannelCreationFailed = fmt.Errorf("NodeErrorChannelCreationFailed")
var ErrNodeErrorChannelClosingFailed = fmt.Errorf("NodeErrorChannelClosingFailed")
var ErrNodeErrorChannelConfigUpdateFailed = fmt.Errorf("NodeErrorChannelConfigUpdateFailed")
var ErrNodeErrorPersistenceFailed = fmt.Errorf("NodeErrorPersistenceFailed")
var ErrNodeErrorWalletOperationFailed = fmt.Errorf("NodeErrorWalletOperationFailed")
var ErrNodeErrorOnchainTxSigningFailed = fmt.Errorf("NodeErrorOnchainTxSigningFailed")
var ErrNodeErrorMessageSigningFailed = fmt.Errorf("NodeErrorMessageSigningFailed")
var ErrNodeErrorTxSyncFailed = fmt.Errorf("NodeErrorTxSyncFailed")
var ErrNodeErrorGossipUpdateFailed = fmt.Errorf("NodeErrorGossipUpdateFailed")
var ErrNodeErrorInvalidAddress = fmt.Errorf("NodeErrorInvalidAddress")
var ErrNodeErrorInvalidNetAddress = fmt.Errorf("NodeErrorInvalidNetAddress")
var ErrNodeErrorInvalidPublicKey = fmt.Errorf("NodeErrorInvalidPublicKey")
var ErrNodeErrorInvalidSecretKey = fmt.Errorf("NodeErrorInvalidSecretKey")
var ErrNodeErrorInvalidPaymentHash = fmt.Errorf("NodeErrorInvalidPaymentHash")
var ErrNodeErrorInvalidPaymentPreimage = fmt.Errorf("NodeErrorInvalidPaymentPreimage")
var ErrNodeErrorInvalidPaymentSecret = fmt.Errorf("NodeErrorInvalidPaymentSecret")
var ErrNodeErrorInvalidAmount = fmt.Errorf("NodeErrorInvalidAmount")
var ErrNodeErrorInvalidInvoice = fmt.Errorf("NodeErrorInvalidInvoice")
var ErrNodeErrorInvalidChannelId = fmt.Errorf("NodeErrorInvalidChannelId")
var ErrNodeErrorInvalidNetwork = fmt.Errorf("NodeErrorInvalidNetwork")
var ErrNodeErrorDuplicatePayment = fmt.Errorf("NodeErrorDuplicatePayment")
var ErrNodeErrorInsufficientFunds = fmt.Errorf("NodeErrorInsufficientFunds")

// Variant structs
type NodeErrorAlreadyRunning struct {
	message string
}

func NewNodeErrorAlreadyRunning() *NodeError {
	return &NodeError{
		err: &NodeErrorAlreadyRunning{},
	}
}

func (err NodeErrorAlreadyRunning) Error() string {
	return fmt.Sprintf("AlreadyRunning: %s", err.message)
}

func (self NodeErrorAlreadyRunning) Is(target error) bool {
	return target == ErrNodeErrorAlreadyRunning
}

type NodeErrorNotRunning struct {
	message string
}

func NewNodeErrorNotRunning() *NodeError {
	return &NodeError{
		err: &NodeErrorNotRunning{},
	}
}

func (err NodeErrorNotRunning) Error() string {
	return fmt.Sprintf("NotRunning: %s", err.message)
}

func (self NodeErrorNotRunning) Is(target error) bool {
	return target == ErrNodeErrorNotRunning
}

type NodeErrorOnchainTxCreationFailed struct {
	message string
}

func NewNodeErrorOnchainTxCreationFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorOnchainTxCreationFailed{},
	}
}

func (err NodeErrorOnchainTxCreationFailed) Error() string {
	return fmt.Sprintf("OnchainTxCreationFailed: %s", err.message)
}

func (self NodeErrorOnchainTxCreationFailed) Is(target error) bool {
	return target == ErrNodeErrorOnchainTxCreationFailed
}

type NodeErrorConnectionFailed struct {
	message string
}

func NewNodeErrorConnectionFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorConnectionFailed{},
	}
}

func (err NodeErrorConnectionFailed) Error() string {
	return fmt.Sprintf("ConnectionFailed: %s", err.message)
}

func (self NodeErrorConnectionFailed) Is(target error) bool {
	return target == ErrNodeErrorConnectionFailed
}

type NodeErrorInvoiceCreationFailed struct {
	message string
}

func NewNodeErrorInvoiceCreationFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorInvoiceCreationFailed{},
	}
}

func (err NodeErrorInvoiceCreationFailed) Error() string {
	return fmt.Sprintf("InvoiceCreationFailed: %s", err.message)
}

func (self NodeErrorInvoiceCreationFailed) Is(target error) bool {
	return target == ErrNodeErrorInvoiceCreationFailed
}

type NodeErrorPaymentSendingFailed struct {
	message string
}

func NewNodeErrorPaymentSendingFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorPaymentSendingFailed{},
	}
}

func (err NodeErrorPaymentSendingFailed) Error() string {
	return fmt.Sprintf("PaymentSendingFailed: %s", err.message)
}

func (self NodeErrorPaymentSendingFailed) Is(target error) bool {
	return target == ErrNodeErrorPaymentSendingFailed
}

type NodeErrorProbeSendingFailed struct {
	message string
}

func NewNodeErrorProbeSendingFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorProbeSendingFailed{},
	}
}

func (err NodeErrorProbeSendingFailed) Error() string {
	return fmt.Sprintf("ProbeSendingFailed: %s", err.message)
}

func (self NodeErrorProbeSendingFailed) Is(target error) bool {
	return target == ErrNodeErrorProbeSendingFailed
}

type NodeErrorChannelCreationFailed struct {
	message string
}

func NewNodeErrorChannelCreationFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorChannelCreationFailed{},
	}
}

func (err NodeErrorChannelCreationFailed) Error() string {
	return fmt.Sprintf("ChannelCreationFailed: %s", err.message)
}

func (self NodeErrorChannelCreationFailed) Is(target error) bool {
	return target == ErrNodeErrorChannelCreationFailed
}

type NodeErrorChannelClosingFailed struct {
	message string
}

func NewNodeErrorChannelClosingFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorChannelClosingFailed{},
	}
}

func (err NodeErrorChannelClosingFailed) Error() string {
	return fmt.Sprintf("ChannelClosingFailed: %s", err.message)
}

func (self NodeErrorChannelClosingFailed) Is(target error) bool {
	return target == ErrNodeErrorChannelClosingFailed
}

type NodeErrorChannelConfigUpdateFailed struct {
	message string
}

func NewNodeErrorChannelConfigUpdateFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorChannelConfigUpdateFailed{},
	}
}

func (err NodeErrorChannelConfigUpdateFailed) Error() string {
	return fmt.Sprintf("ChannelConfigUpdateFailed: %s", err.message)
}

func (self NodeErrorChannelConfigUpdateFailed) Is(target error) bool {
	return target == ErrNodeErrorChannelConfigUpdateFailed
}

type NodeErrorPersistenceFailed struct {
	message string
}

func NewNodeErrorPersistenceFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorPersistenceFailed{},
	}
}

func (err NodeErrorPersistenceFailed) Error() string {
	return fmt.Sprintf("PersistenceFailed: %s", err.message)
}

func (self NodeErrorPersistenceFailed) Is(target error) bool {
	return target == ErrNodeErrorPersistenceFailed
}

type NodeErrorWalletOperationFailed struct {
	message string
}

func NewNodeErrorWalletOperationFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorWalletOperationFailed{},
	}
}

func (err NodeErrorWalletOperationFailed) Error() string {
	return fmt.Sprintf("WalletOperationFailed: %s", err.message)
}

func (self NodeErrorWalletOperationFailed) Is(target error) bool {
	return target == ErrNodeErrorWalletOperationFailed
}

type NodeErrorOnchainTxSigningFailed struct {
	message string
}

func NewNodeErrorOnchainTxSigningFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorOnchainTxSigningFailed{},
	}
}

func (err NodeErrorOnchainTxSigningFailed) Error() string {
	return fmt.Sprintf("OnchainTxSigningFailed: %s", err.message)
}

func (self NodeErrorOnchainTxSigningFailed) Is(target error) bool {
	return target == ErrNodeErrorOnchainTxSigningFailed
}

type NodeErrorMessageSigningFailed struct {
	message string
}

func NewNodeErrorMessageSigningFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorMessageSigningFailed{},
	}
}

func (err NodeErrorMessageSigningFailed) Error() string {
	return fmt.Sprintf("MessageSigningFailed: %s", err.message)
}

func (self NodeErrorMessageSigningFailed) Is(target error) bool {
	return target == ErrNodeErrorMessageSigningFailed
}

type NodeErrorTxSyncFailed struct {
	message string
}

func NewNodeErrorTxSyncFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorTxSyncFailed{},
	}
}

func (err NodeErrorTxSyncFailed) Error() string {
	return fmt.Sprintf("TxSyncFailed: %s", err.message)
}

func (self NodeErrorTxSyncFailed) Is(target error) bool {
	return target == ErrNodeErrorTxSyncFailed
}

type NodeErrorGossipUpdateFailed struct {
	message string
}

func NewNodeErrorGossipUpdateFailed() *NodeError {
	return &NodeError{
		err: &NodeErrorGossipUpdateFailed{},
	}
}

func (err NodeErrorGossipUpdateFailed) Error() string {
	return fmt.Sprintf("GossipUpdateFailed: %s", err.message)
}

func (self NodeErrorGossipUpdateFailed) Is(target error) bool {
	return target == ErrNodeErrorGossipUpdateFailed
}

type NodeErrorInvalidAddress struct {
	message string
}

func NewNodeErrorInvalidAddress() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidAddress{},
	}
}

func (err NodeErrorInvalidAddress) Error() string {
	return fmt.Sprintf("InvalidAddress: %s", err.message)
}

func (self NodeErrorInvalidAddress) Is(target error) bool {
	return target == ErrNodeErrorInvalidAddress
}

type NodeErrorInvalidNetAddress struct {
	message string
}

func NewNodeErrorInvalidNetAddress() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidNetAddress{},
	}
}

func (err NodeErrorInvalidNetAddress) Error() string {
	return fmt.Sprintf("InvalidNetAddress: %s", err.message)
}

func (self NodeErrorInvalidNetAddress) Is(target error) bool {
	return target == ErrNodeErrorInvalidNetAddress
}

type NodeErrorInvalidPublicKey struct {
	message string
}

func NewNodeErrorInvalidPublicKey() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidPublicKey{},
	}
}

func (err NodeErrorInvalidPublicKey) Error() string {
	return fmt.Sprintf("InvalidPublicKey: %s", err.message)
}

func (self NodeErrorInvalidPublicKey) Is(target error) bool {
	return target == ErrNodeErrorInvalidPublicKey
}

type NodeErrorInvalidSecretKey struct {
	message string
}

func NewNodeErrorInvalidSecretKey() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidSecretKey{},
	}
}

func (err NodeErrorInvalidSecretKey) Error() string {
	return fmt.Sprintf("InvalidSecretKey: %s", err.message)
}

func (self NodeErrorInvalidSecretKey) Is(target error) bool {
	return target == ErrNodeErrorInvalidSecretKey
}

type NodeErrorInvalidPaymentHash struct {
	message string
}

func NewNodeErrorInvalidPaymentHash() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidPaymentHash{},
	}
}

func (err NodeErrorInvalidPaymentHash) Error() string {
	return fmt.Sprintf("InvalidPaymentHash: %s", err.message)
}

func (self NodeErrorInvalidPaymentHash) Is(target error) bool {
	return target == ErrNodeErrorInvalidPaymentHash
}

type NodeErrorInvalidPaymentPreimage struct {
	message string
}

func NewNodeErrorInvalidPaymentPreimage() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidPaymentPreimage{},
	}
}

func (err NodeErrorInvalidPaymentPreimage) Error() string {
	return fmt.Sprintf("InvalidPaymentPreimage: %s", err.message)
}

func (self NodeErrorInvalidPaymentPreimage) Is(target error) bool {
	return target == ErrNodeErrorInvalidPaymentPreimage
}

type NodeErrorInvalidPaymentSecret struct {
	message string
}

func NewNodeErrorInvalidPaymentSecret() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidPaymentSecret{},
	}
}

func (err NodeErrorInvalidPaymentSecret) Error() string {
	return fmt.Sprintf("InvalidPaymentSecret: %s", err.message)
}

func (self NodeErrorInvalidPaymentSecret) Is(target error) bool {
	return target == ErrNodeErrorInvalidPaymentSecret
}

type NodeErrorInvalidAmount struct {
	message string
}

func NewNodeErrorInvalidAmount() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidAmount{},
	}
}

func (err NodeErrorInvalidAmount) Error() string {
	return fmt.Sprintf("InvalidAmount: %s", err.message)
}

func (self NodeErrorInvalidAmount) Is(target error) bool {
	return target == ErrNodeErrorInvalidAmount
}

type NodeErrorInvalidInvoice struct {
	message string
}

func NewNodeErrorInvalidInvoice() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidInvoice{},
	}
}

func (err NodeErrorInvalidInvoice) Error() string {
	return fmt.Sprintf("InvalidInvoice: %s", err.message)
}

func (self NodeErrorInvalidInvoice) Is(target error) bool {
	return target == ErrNodeErrorInvalidInvoice
}

type NodeErrorInvalidChannelId struct {
	message string
}

func NewNodeErrorInvalidChannelId() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidChannelId{},
	}
}

func (err NodeErrorInvalidChannelId) Error() string {
	return fmt.Sprintf("InvalidChannelId: %s", err.message)
}

func (self NodeErrorInvalidChannelId) Is(target error) bool {
	return target == ErrNodeErrorInvalidChannelId
}

type NodeErrorInvalidNetwork struct {
	message string
}

func NewNodeErrorInvalidNetwork() *NodeError {
	return &NodeError{
		err: &NodeErrorInvalidNetwork{},
	}
}

func (err NodeErrorInvalidNetwork) Error() string {
	return fmt.Sprintf("InvalidNetwork: %s", err.message)
}

func (self NodeErrorInvalidNetwork) Is(target error) bool {
	return target == ErrNodeErrorInvalidNetwork
}

type NodeErrorDuplicatePayment struct {
	message string
}

func NewNodeErrorDuplicatePayment() *NodeError {
	return &NodeError{
		err: &NodeErrorDuplicatePayment{},
	}
}

func (err NodeErrorDuplicatePayment) Error() string {
	return fmt.Sprintf("DuplicatePayment: %s", err.message)
}

func (self NodeErrorDuplicatePayment) Is(target error) bool {
	return target == ErrNodeErrorDuplicatePayment
}

type NodeErrorInsufficientFunds struct {
	message string
}

func NewNodeErrorInsufficientFunds() *NodeError {
	return &NodeError{
		err: &NodeErrorInsufficientFunds{},
	}
}

func (err NodeErrorInsufficientFunds) Error() string {
	return fmt.Sprintf("InsufficientFunds: %s", err.message)
}

func (self NodeErrorInsufficientFunds) Is(target error) bool {
	return target == ErrNodeErrorInsufficientFunds
}

type FfiConverterTypeNodeError struct{}

var FfiConverterTypeNodeErrorINSTANCE = FfiConverterTypeNodeError{}

func (c FfiConverterTypeNodeError) lift(cErrBuf C.RustBuffer) error {
	errBuf := fromCRustBuffer(cErrBuf)
	return liftFromRustBuffer[error](c, errBuf)
}

func (c FfiConverterTypeNodeError) lower(value *NodeError) C.RustBuffer {
	return lowerIntoRustBuffer[*NodeError](c, value)
}

func (c FfiConverterTypeNodeError) read(reader io.Reader) error {
	errorID := readUint32(reader)

	message := FfiConverterstringINSTANCE.read(reader)
	switch errorID {
	case 1:
		return &NodeError{&NodeErrorAlreadyRunning{message}}
	case 2:
		return &NodeError{&NodeErrorNotRunning{message}}
	case 3:
		return &NodeError{&NodeErrorOnchainTxCreationFailed{message}}
	case 4:
		return &NodeError{&NodeErrorConnectionFailed{message}}
	case 5:
		return &NodeError{&NodeErrorInvoiceCreationFailed{message}}
	case 6:
		return &NodeError{&NodeErrorPaymentSendingFailed{message}}
	case 7:
		return &NodeError{&NodeErrorProbeSendingFailed{message}}
	case 8:
		return &NodeError{&NodeErrorChannelCreationFailed{message}}
	case 9:
		return &NodeError{&NodeErrorChannelClosingFailed{message}}
	case 10:
		return &NodeError{&NodeErrorChannelConfigUpdateFailed{message}}
	case 11:
		return &NodeError{&NodeErrorPersistenceFailed{message}}
	case 12:
		return &NodeError{&NodeErrorWalletOperationFailed{message}}
	case 13:
		return &NodeError{&NodeErrorOnchainTxSigningFailed{message}}
	case 14:
		return &NodeError{&NodeErrorMessageSigningFailed{message}}
	case 15:
		return &NodeError{&NodeErrorTxSyncFailed{message}}
	case 16:
		return &NodeError{&NodeErrorGossipUpdateFailed{message}}
	case 17:
		return &NodeError{&NodeErrorInvalidAddress{message}}
	case 18:
		return &NodeError{&NodeErrorInvalidNetAddress{message}}
	case 19:
		return &NodeError{&NodeErrorInvalidPublicKey{message}}
	case 20:
		return &NodeError{&NodeErrorInvalidSecretKey{message}}
	case 21:
		return &NodeError{&NodeErrorInvalidPaymentHash{message}}
	case 22:
		return &NodeError{&NodeErrorInvalidPaymentPreimage{message}}
	case 23:
		return &NodeError{&NodeErrorInvalidPaymentSecret{message}}
	case 24:
		return &NodeError{&NodeErrorInvalidAmount{message}}
	case 25:
		return &NodeError{&NodeErrorInvalidInvoice{message}}
	case 26:
		return &NodeError{&NodeErrorInvalidChannelId{message}}
	case 27:
		return &NodeError{&NodeErrorInvalidNetwork{message}}
	case 28:
		return &NodeError{&NodeErrorDuplicatePayment{message}}
	case 29:
		return &NodeError{&NodeErrorInsufficientFunds{message}}
	default:
		panic(fmt.Sprintf("Unknown error code %d in FfiConverterTypeNodeError.read()", errorID))
	}

}

func (c FfiConverterTypeNodeError) write(writer io.Writer, value *NodeError) {
	switch variantValue := value.err.(type) {
	case *NodeErrorAlreadyRunning:
		writeInt32(writer, 1)
	case *NodeErrorNotRunning:
		writeInt32(writer, 2)
	case *NodeErrorOnchainTxCreationFailed:
		writeInt32(writer, 3)
	case *NodeErrorConnectionFailed:
		writeInt32(writer, 4)
	case *NodeErrorInvoiceCreationFailed:
		writeInt32(writer, 5)
	case *NodeErrorPaymentSendingFailed:
		writeInt32(writer, 6)
	case *NodeErrorProbeSendingFailed:
		writeInt32(writer, 7)
	case *NodeErrorChannelCreationFailed:
		writeInt32(writer, 8)
	case *NodeErrorChannelClosingFailed:
		writeInt32(writer, 9)
	case *NodeErrorChannelConfigUpdateFailed:
		writeInt32(writer, 10)
	case *NodeErrorPersistenceFailed:
		writeInt32(writer, 11)
	case *NodeErrorWalletOperationFailed:
		writeInt32(writer, 12)
	case *NodeErrorOnchainTxSigningFailed:
		writeInt32(writer, 13)
	case *NodeErrorMessageSigningFailed:
		writeInt32(writer, 14)
	case *NodeErrorTxSyncFailed:
		writeInt32(writer, 15)
	case *NodeErrorGossipUpdateFailed:
		writeInt32(writer, 16)
	case *NodeErrorInvalidAddress:
		writeInt32(writer, 17)
	case *NodeErrorInvalidNetAddress:
		writeInt32(writer, 18)
	case *NodeErrorInvalidPublicKey:
		writeInt32(writer, 19)
	case *NodeErrorInvalidSecretKey:
		writeInt32(writer, 20)
	case *NodeErrorInvalidPaymentHash:
		writeInt32(writer, 21)
	case *NodeErrorInvalidPaymentPreimage:
		writeInt32(writer, 22)
	case *NodeErrorInvalidPaymentSecret:
		writeInt32(writer, 23)
	case *NodeErrorInvalidAmount:
		writeInt32(writer, 24)
	case *NodeErrorInvalidInvoice:
		writeInt32(writer, 25)
	case *NodeErrorInvalidChannelId:
		writeInt32(writer, 26)
	case *NodeErrorInvalidNetwork:
		writeInt32(writer, 27)
	case *NodeErrorDuplicatePayment:
		writeInt32(writer, 28)
	case *NodeErrorInsufficientFunds:
		writeInt32(writer, 29)
	default:
		_ = variantValue
		panic(fmt.Sprintf("invalid error value `%v` in FfiConverterTypeNodeError.write", value))
	}
}

type FfiConverterOptionaluint16 struct{}

var FfiConverterOptionaluint16INSTANCE = FfiConverterOptionaluint16{}

func (c FfiConverterOptionaluint16) lift(cRustBuf C.RustBuffer) *uint16 {
	return liftFromRustBuffer[*uint16](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionaluint16) read(reader io.Reader) *uint16 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverteruint16INSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionaluint16) lower(value *uint16) C.RustBuffer {
	return lowerIntoRustBuffer[*uint16](c, value)
}

func (_ FfiConverterOptionaluint16) write(writer io.Writer, value *uint16) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverteruint16INSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionaluint16 struct{}

func (_ FfiDestroyerOptionaluint16) destroy(value *uint16) {
	if value != nil {
		FfiDestroyeruint16{}.destroy(*value)
	}
}

type FfiConverterOptionaluint32 struct{}

var FfiConverterOptionaluint32INSTANCE = FfiConverterOptionaluint32{}

func (c FfiConverterOptionaluint32) lift(cRustBuf C.RustBuffer) *uint32 {
	return liftFromRustBuffer[*uint32](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionaluint32) read(reader io.Reader) *uint32 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverteruint32INSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionaluint32) lower(value *uint32) C.RustBuffer {
	return lowerIntoRustBuffer[*uint32](c, value)
}

func (_ FfiConverterOptionaluint32) write(writer io.Writer, value *uint32) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverteruint32INSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionaluint32 struct{}

func (_ FfiDestroyerOptionaluint32) destroy(value *uint32) {
	if value != nil {
		FfiDestroyeruint32{}.destroy(*value)
	}
}

type FfiConverterOptionaluint64 struct{}

var FfiConverterOptionaluint64INSTANCE = FfiConverterOptionaluint64{}

func (c FfiConverterOptionaluint64) lift(cRustBuf C.RustBuffer) *uint64 {
	return liftFromRustBuffer[*uint64](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionaluint64) read(reader io.Reader) *uint64 {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverteruint64INSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionaluint64) lower(value *uint64) C.RustBuffer {
	return lowerIntoRustBuffer[*uint64](c, value)
}

func (_ FfiConverterOptionaluint64) write(writer io.Writer, value *uint64) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverteruint64INSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionaluint64 struct{}

func (_ FfiDestroyerOptionaluint64) destroy(value *uint64) {
	if value != nil {
		FfiDestroyeruint64{}.destroy(*value)
	}
}

type FfiConverterOptionalstring struct{}

var FfiConverterOptionalstringINSTANCE = FfiConverterOptionalstring{}

func (c FfiConverterOptionalstring) lift(cRustBuf C.RustBuffer) *string {
	return liftFromRustBuffer[*string](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalstring) read(reader io.Reader) *string {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterstringINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalstring) lower(value *string) C.RustBuffer {
	return lowerIntoRustBuffer[*string](c, value)
}

func (_ FfiConverterOptionalstring) write(writer io.Writer, value *string) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterstringINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalstring struct{}

func (_ FfiDestroyerOptionalstring) destroy(value *string) {
	if value != nil {
		FfiDestroyerstring{}.destroy(*value)
	}
}

type FfiConverterOptionalChannelConfig struct{}

var FfiConverterOptionalChannelConfigINSTANCE = FfiConverterOptionalChannelConfig{}

func (c FfiConverterOptionalChannelConfig) lift(cRustBuf C.RustBuffer) **ChannelConfig {
	return liftFromRustBuffer[**ChannelConfig](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalChannelConfig) read(reader io.Reader) **ChannelConfig {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterChannelConfigINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalChannelConfig) lower(value **ChannelConfig) C.RustBuffer {
	return lowerIntoRustBuffer[**ChannelConfig](c, value)
}

func (_ FfiConverterOptionalChannelConfig) write(writer io.Writer, value **ChannelConfig) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterChannelConfigINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalChannelConfig struct{}

func (_ FfiDestroyerOptionalChannelConfig) destroy(value **ChannelConfig) {
	if value != nil {
		FfiDestroyerChannelConfig{}.destroy(*value)
	}
}

type FfiConverterOptionalTypeOutPoint struct{}

var FfiConverterOptionalTypeOutPointINSTANCE = FfiConverterOptionalTypeOutPoint{}

func (c FfiConverterOptionalTypeOutPoint) lift(cRustBuf C.RustBuffer) *OutPoint {
	return liftFromRustBuffer[*OutPoint](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalTypeOutPoint) read(reader io.Reader) *OutPoint {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypeOutPointINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalTypeOutPoint) lower(value *OutPoint) C.RustBuffer {
	return lowerIntoRustBuffer[*OutPoint](c, value)
}

func (_ FfiConverterOptionalTypeOutPoint) write(writer io.Writer, value *OutPoint) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypeOutPointINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalTypeOutPoint struct{}

func (_ FfiDestroyerOptionalTypeOutPoint) destroy(value *OutPoint) {
	if value != nil {
		FfiDestroyerTypeOutPoint{}.destroy(*value)
	}
}

type FfiConverterOptionalTypePaymentDetails struct{}

var FfiConverterOptionalTypePaymentDetailsINSTANCE = FfiConverterOptionalTypePaymentDetails{}

func (c FfiConverterOptionalTypePaymentDetails) lift(cRustBuf C.RustBuffer) *PaymentDetails {
	return liftFromRustBuffer[*PaymentDetails](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalTypePaymentDetails) read(reader io.Reader) *PaymentDetails {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypePaymentDetailsINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalTypePaymentDetails) lower(value *PaymentDetails) C.RustBuffer {
	return lowerIntoRustBuffer[*PaymentDetails](c, value)
}

func (_ FfiConverterOptionalTypePaymentDetails) write(writer io.Writer, value *PaymentDetails) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypePaymentDetailsINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalTypePaymentDetails struct{}

func (_ FfiDestroyerOptionalTypePaymentDetails) destroy(value *PaymentDetails) {
	if value != nil {
		FfiDestroyerTypePaymentDetails{}.destroy(*value)
	}
}

type FfiConverterOptionalTypeEvent struct{}

var FfiConverterOptionalTypeEventINSTANCE = FfiConverterOptionalTypeEvent{}

func (c FfiConverterOptionalTypeEvent) lift(cRustBuf C.RustBuffer) *Event {
	return liftFromRustBuffer[*Event](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalTypeEvent) read(reader io.Reader) *Event {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypeEventINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalTypeEvent) lower(value *Event) C.RustBuffer {
	return lowerIntoRustBuffer[*Event](c, value)
}

func (_ FfiConverterOptionalTypeEvent) write(writer io.Writer, value *Event) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypeEventINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalTypeEvent struct{}

func (_ FfiDestroyerOptionalTypeEvent) destroy(value *Event) {
	if value != nil {
		FfiDestroyerTypeEvent{}.destroy(*value)
	}
}

type FfiConverterOptionalTypeNetAddress struct{}

var FfiConverterOptionalTypeNetAddressINSTANCE = FfiConverterOptionalTypeNetAddress{}

func (c FfiConverterOptionalTypeNetAddress) lift(cRustBuf C.RustBuffer) *NetAddress {
	return liftFromRustBuffer[*NetAddress](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalTypeNetAddress) read(reader io.Reader) *NetAddress {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypeNetAddressINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalTypeNetAddress) lower(value *NetAddress) C.RustBuffer {
	return lowerIntoRustBuffer[*NetAddress](c, value)
}

func (_ FfiConverterOptionalTypeNetAddress) write(writer io.Writer, value *NetAddress) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypeNetAddressINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalTypeNetAddress struct{}

func (_ FfiDestroyerOptionalTypeNetAddress) destroy(value *NetAddress) {
	if value != nil {
		FfiDestroyerTypeNetAddress{}.destroy(*value)
	}
}

type FfiConverterOptionalTypePaymentPreimage struct{}

var FfiConverterOptionalTypePaymentPreimageINSTANCE = FfiConverterOptionalTypePaymentPreimage{}

func (c FfiConverterOptionalTypePaymentPreimage) lift(cRustBuf C.RustBuffer) *PaymentPreimage {
	return liftFromRustBuffer[*PaymentPreimage](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalTypePaymentPreimage) read(reader io.Reader) *PaymentPreimage {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypePaymentPreimageINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalTypePaymentPreimage) lower(value *PaymentPreimage) C.RustBuffer {
	return lowerIntoRustBuffer[*PaymentPreimage](c, value)
}

func (_ FfiConverterOptionalTypePaymentPreimage) write(writer io.Writer, value *PaymentPreimage) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypePaymentPreimageINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalTypePaymentPreimage struct{}

func (_ FfiDestroyerOptionalTypePaymentPreimage) destroy(value *PaymentPreimage) {
	if value != nil {
		FfiDestroyerTypePaymentPreimage{}.destroy(*value)
	}
}

type FfiConverterOptionalTypePaymentSecret struct{}

var FfiConverterOptionalTypePaymentSecretINSTANCE = FfiConverterOptionalTypePaymentSecret{}

func (c FfiConverterOptionalTypePaymentSecret) lift(cRustBuf C.RustBuffer) *PaymentSecret {
	return liftFromRustBuffer[*PaymentSecret](c, fromCRustBuffer(cRustBuf))
}

func (_ FfiConverterOptionalTypePaymentSecret) read(reader io.Reader) *PaymentSecret {
	if readInt8(reader) == 0 {
		return nil
	}
	temp := FfiConverterTypePaymentSecretINSTANCE.read(reader)
	return &temp
}

func (c FfiConverterOptionalTypePaymentSecret) lower(value *PaymentSecret) C.RustBuffer {
	return lowerIntoRustBuffer[*PaymentSecret](c, value)
}

func (_ FfiConverterOptionalTypePaymentSecret) write(writer io.Writer, value *PaymentSecret) {
	if value == nil {
		writeInt8(writer, 0)
	} else {
		writeInt8(writer, 1)
		FfiConverterTypePaymentSecretINSTANCE.write(writer, *value)
	}
}

type FfiDestroyerOptionalTypePaymentSecret struct{}

func (_ FfiDestroyerOptionalTypePaymentSecret) destroy(value *PaymentSecret) {
	if value != nil {
		FfiDestroyerTypePaymentSecret{}.destroy(*value)
	}
}

type FfiConverterSequenceuint8 struct{}

var FfiConverterSequenceuint8INSTANCE = FfiConverterSequenceuint8{}

func (c FfiConverterSequenceuint8) lift(cRustBuf C.RustBuffer) []uint8 {
	return liftFromRustBuffer[[]uint8](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterSequenceuint8) read(reader io.Reader) []uint8 {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]uint8, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverteruint8INSTANCE.read(reader))
	}
	return result
}

func (c FfiConverterSequenceuint8) lower(value []uint8) C.RustBuffer {
	return lowerIntoRustBuffer[[]uint8](c, value)
}

func (c FfiConverterSequenceuint8) write(writer io.Writer, value []uint8) {
	if len(value) > math.MaxInt32 {
		panic("[]uint8 is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverteruint8INSTANCE.write(writer, item)
	}
}

type FfiDestroyerSequenceuint8 struct{}

func (FfiDestroyerSequenceuint8) destroy(sequence []uint8) {
	for _, value := range sequence {
		FfiDestroyeruint8{}.destroy(value)
	}
}

type FfiConverterSequenceTypeChannelDetails struct{}

var FfiConverterSequenceTypeChannelDetailsINSTANCE = FfiConverterSequenceTypeChannelDetails{}

func (c FfiConverterSequenceTypeChannelDetails) lift(cRustBuf C.RustBuffer) []ChannelDetails {
	return liftFromRustBuffer[[]ChannelDetails](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterSequenceTypeChannelDetails) read(reader io.Reader) []ChannelDetails {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]ChannelDetails, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTypeChannelDetailsINSTANCE.read(reader))
	}
	return result
}

func (c FfiConverterSequenceTypeChannelDetails) lower(value []ChannelDetails) C.RustBuffer {
	return lowerIntoRustBuffer[[]ChannelDetails](c, value)
}

func (c FfiConverterSequenceTypeChannelDetails) write(writer io.Writer, value []ChannelDetails) {
	if len(value) > math.MaxInt32 {
		panic("[]ChannelDetails is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTypeChannelDetailsINSTANCE.write(writer, item)
	}
}

type FfiDestroyerSequenceTypeChannelDetails struct{}

func (FfiDestroyerSequenceTypeChannelDetails) destroy(sequence []ChannelDetails) {
	for _, value := range sequence {
		FfiDestroyerTypeChannelDetails{}.destroy(value)
	}
}

type FfiConverterSequenceTypePaymentDetails struct{}

var FfiConverterSequenceTypePaymentDetailsINSTANCE = FfiConverterSequenceTypePaymentDetails{}

func (c FfiConverterSequenceTypePaymentDetails) lift(cRustBuf C.RustBuffer) []PaymentDetails {
	return liftFromRustBuffer[[]PaymentDetails](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterSequenceTypePaymentDetails) read(reader io.Reader) []PaymentDetails {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]PaymentDetails, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTypePaymentDetailsINSTANCE.read(reader))
	}
	return result
}

func (c FfiConverterSequenceTypePaymentDetails) lower(value []PaymentDetails) C.RustBuffer {
	return lowerIntoRustBuffer[[]PaymentDetails](c, value)
}

func (c FfiConverterSequenceTypePaymentDetails) write(writer io.Writer, value []PaymentDetails) {
	if len(value) > math.MaxInt32 {
		panic("[]PaymentDetails is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTypePaymentDetailsINSTANCE.write(writer, item)
	}
}

type FfiDestroyerSequenceTypePaymentDetails struct{}

func (FfiDestroyerSequenceTypePaymentDetails) destroy(sequence []PaymentDetails) {
	for _, value := range sequence {
		FfiDestroyerTypePaymentDetails{}.destroy(value)
	}
}

type FfiConverterSequenceTypePeerDetails struct{}

var FfiConverterSequenceTypePeerDetailsINSTANCE = FfiConverterSequenceTypePeerDetails{}

func (c FfiConverterSequenceTypePeerDetails) lift(cRustBuf C.RustBuffer) []PeerDetails {
	return liftFromRustBuffer[[]PeerDetails](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterSequenceTypePeerDetails) read(reader io.Reader) []PeerDetails {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]PeerDetails, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTypePeerDetailsINSTANCE.read(reader))
	}
	return result
}

func (c FfiConverterSequenceTypePeerDetails) lower(value []PeerDetails) C.RustBuffer {
	return lowerIntoRustBuffer[[]PeerDetails](c, value)
}

func (c FfiConverterSequenceTypePeerDetails) write(writer io.Writer, value []PeerDetails) {
	if len(value) > math.MaxInt32 {
		panic("[]PeerDetails is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTypePeerDetailsINSTANCE.write(writer, item)
	}
}

type FfiDestroyerSequenceTypePeerDetails struct{}

func (FfiDestroyerSequenceTypePeerDetails) destroy(sequence []PeerDetails) {
	for _, value := range sequence {
		FfiDestroyerTypePeerDetails{}.destroy(value)
	}
}

type FfiConverterSequenceTypePublicKey struct{}

var FfiConverterSequenceTypePublicKeyINSTANCE = FfiConverterSequenceTypePublicKey{}

func (c FfiConverterSequenceTypePublicKey) lift(cRustBuf C.RustBuffer) []PublicKey {
	return liftFromRustBuffer[[]PublicKey](c, fromCRustBuffer(cRustBuf))
}

func (c FfiConverterSequenceTypePublicKey) read(reader io.Reader) []PublicKey {
	length := readInt32(reader)
	if length == 0 {
		return nil
	}
	result := make([]PublicKey, 0, length)
	for i := int32(0); i < length; i++ {
		result = append(result, FfiConverterTypePublicKeyINSTANCE.read(reader))
	}
	return result
}

func (c FfiConverterSequenceTypePublicKey) lower(value []PublicKey) C.RustBuffer {
	return lowerIntoRustBuffer[[]PublicKey](c, value)
}

func (c FfiConverterSequenceTypePublicKey) write(writer io.Writer, value []PublicKey) {
	if len(value) > math.MaxInt32 {
		panic("[]PublicKey is too large to fit into Int32")
	}

	writeInt32(writer, int32(len(value)))
	for _, item := range value {
		FfiConverterTypePublicKeyINSTANCE.write(writer, item)
	}
}

type FfiDestroyerSequenceTypePublicKey struct{}

func (FfiDestroyerSequenceTypePublicKey) destroy(sequence []PublicKey) {
	for _, value := range sequence {
		FfiDestroyerTypePublicKey{}.destroy(value)
	}
}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type Address = string
type FfiConverterTypeAddress = FfiConverterstring
type FfiDestroyerTypeAddress = FfiDestroyerstring

var FfiConverterTypeAddressINSTANCE = FfiConverterstring{}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type Bolt11Invoice = string
type FfiConverterTypeBolt11Invoice = FfiConverterstring
type FfiDestroyerTypeBolt11Invoice = FfiDestroyerstring

var FfiConverterTypeBolt11InvoiceINSTANCE = FfiConverterstring{}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type ChannelId = string
type FfiConverterTypeChannelId = FfiConverterstring
type FfiDestroyerTypeChannelId = FfiDestroyerstring

var FfiConverterTypeChannelIdINSTANCE = FfiConverterstring{}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type Mnemonic = string
type FfiConverterTypeMnemonic = FfiConverterstring
type FfiDestroyerTypeMnemonic = FfiDestroyerstring

var FfiConverterTypeMnemonicINSTANCE = FfiConverterstring{}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type NetAddress = string
type FfiConverterTypeNetAddress = FfiConverterstring
type FfiDestroyerTypeNetAddress = FfiDestroyerstring

var FfiConverterTypeNetAddressINSTANCE = FfiConverterstring{}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type PaymentHash = string
type FfiConverterTypePaymentHash = FfiConverterstring
type FfiDestroyerTypePaymentHash = FfiDestroyerstring

var FfiConverterTypePaymentHashINSTANCE = FfiConverterstring{}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type PaymentPreimage = string
type FfiConverterTypePaymentPreimage = FfiConverterstring
type FfiDestroyerTypePaymentPreimage = FfiDestroyerstring

var FfiConverterTypePaymentPreimageINSTANCE = FfiConverterstring{}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type PaymentSecret = string
type FfiConverterTypePaymentSecret = FfiConverterstring
type FfiDestroyerTypePaymentSecret = FfiDestroyerstring

var FfiConverterTypePaymentSecretINSTANCE = FfiConverterstring{}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type PublicKey = string
type FfiConverterTypePublicKey = FfiConverterstring
type FfiDestroyerTypePublicKey = FfiDestroyerstring

var FfiConverterTypePublicKeyINSTANCE = FfiConverterstring{}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type Txid = string
type FfiConverterTypeTxid = FfiConverterstring
type FfiDestroyerTypeTxid = FfiDestroyerstring

var FfiConverterTypeTxidINSTANCE = FfiConverterstring{}

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */
type UserChannelId = string
type FfiConverterTypeUserChannelId = FfiConverterstring
type FfiDestroyerTypeUserChannelId = FfiDestroyerstring

var FfiConverterTypeUserChannelIdINSTANCE = FfiConverterstring{}

func GenerateEntropyMnemonic() Mnemonic {

	return FfiConverterTypeMnemonicINSTANCE.lift(rustCall(func(_uniffiStatus *C.RustCallStatus) C.RustBuffer {
		return C.ldk_node_cc4c_generate_entropy_mnemonic(_uniffiStatus)
	}))

}
